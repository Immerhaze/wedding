<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>S&J</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <style>
    :root {
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #000;
      overflow: hidden;
      touch-action: manipulation; /* better mobile taps */
    }
    /* Use dynamic viewport units on modern mobile, with fallbacks */
    #game-root {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100dvh;          /* modern mobile */
      height: 100svh;          /* small viewport fallback */
      height: 100vh;           /* final fallback */
      padding-top: var(--safe-top);
      padding-right: var(--safe-right);
      padding-bottom: var(--safe-bottom);
      padding-left: var(--safe-left);
    }
    #game-root canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
      image-rendering: pixelated;
    }

    /* --- Mobile on-screen controls --- */
    .mobile-controls {
      position: fixed;
      inset: auto 0 var(--safe-bottom) 0;
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      padding: 10px 14px calc(10px + var(--safe-bottom));
      pointer-events: none; /* children handle events */
      z-index: 999999;
    }
    .mc-btn {
      pointer-events: auto;
      user-select: none;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      font-family: monospace;
      font-size: 18px;
      color: #fff;
      background: rgba(20, 20, 20, 0.45);
      border: 2px solid rgba(0, 255, 255, 0.6);
      border-radius: 14px;
      padding: 14px 10px;
      text-align: center;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    
/* Prevent text selection / long-press menus inside mobile buttons */
.mc-btn, .mc-btn * {
  user-select: none;
  -webkit-user-select: none;    /* iOS Safari */
  -ms-user-select: none;
  -moz-user-select: none;
  -webkit-touch-callout: none;  /* no copy/share popup on long-press */
  caret-color: transparent;     /* no caret flash */
}
    .mc-btn:active,
    .mc-btn.mc-pressed {
      background: rgba(0, 255, 255, 0.22);
      border-color: rgba(0, 255, 255, 0.95);
    }
    .mc-spacer { visibility: hidden; }
    @media (min-width: 900px) {
      .mobile-controls { display: none; }
    }
  </style>
</head>
<body>
  <div id="game-root"></div>
  <!-- Mobile controls -->
  <div class="mobile-controls" id="mobileControls" aria-hidden="true">
    <button id="btnLeft" class="mc-btn" aria-label="Move Left">◀</button>
    <div class="mc-spacer"></div>
    <button id="btnRight" class="mc-btn" aria-label="Move Right">▶</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>

  <script>



  /* ================================================
     Global state & helpers
  ================================================= */
  const GameState = { sound: true, character: null, bgm: null };

  // Titles per zone (1..9)
  const ZONE_TITLES = {
    1: 'Un Comienzo',
    2: 'Entre Tonadas',
    3: 'El Paseo Diario',
    4: 'Mi Cancion Favorita',
    5: 'Nuestro Pequeño Locky',
    6: 'Aniversario En Pandemia',
    7: 'Entonces Fuimos Cuatro',
    8: 'Bajando Estrellas',
    9: 'El Dia Esperado',
  };

  // DEBUG background frames
  const ZONE_BG_COLORS  = [0x263238, 0x3E2723, 0x1B5E20, 0x4A148C];
  const ZONE_BG_ALPHA   = 0.18;
  const SHOW_ZONE_EDGES = true;

  // DPI-aware resolution: cap for battery/heat
  const DPR = Math.min(window.devicePixelRatio || 1, 2);

  // Prevent iOS rubber-band scroll
  document.addEventListener('touchmove', (e) => {
    if (e.target.closest('#game-root')) e.preventDefault();
  }, { passive: false });

  // World position helper for container children
  function _worldPos(scene, container, obj) {
    const sx = container.scaleX ?? 1;
    const sy = container.scaleY ?? 1;
    return {
      x: container.x + (obj.x * sx),
      y: container.y + (obj.y * sy),
      w: (obj.displayWidth ?? obj.width ?? 0) * sx,
      h: (obj.displayHeight ?? obj.height ?? 0) * sy,
    };
  }

  function _clampToViewX(scene, x, pad = 16){
  const cam = scene.cameras.main;
  const left  = cam.worldView.left  + pad;
  const right = cam.worldView.right - pad;
  return Phaser.Math.Clamp(x, left, right);
}


  /* Bubble helpers (player + NPC) shared by several scenes */
  function _s4ShowBubble(scene, text, opts = {}) {
    const { autoHideMs = 1800 } = opts;
    const s4 = scene._s4;

    if (scene._playerBubble) {
      if (scene._playerBubble._follow) scene._playerBubble._follow.remove(false);
      scene._playerBubble.destroy(true);
    }

    const bubble = scene.add.text(
      scene.player.x,
      scene.player.y - scene.player.displayHeight - 40,
      text,
      { fontFamily:"monospace", fontSize:14, color:"#ffffff", backgroundColor:"#000000", align:"center" }
    ).setOrigin(0.5,1).setDepth(6500).setAlpha(0);
    scene._playerBubble = bubble;

    scene.tweens.add({ targets:bubble, alpha:1, duration:300 });
bubble._follow = scene.time.addEvent({
  delay:16, loop:true, callback:()=>{
    const bx = _clampToViewX(scene, scene.player.x);
    bubble.setPosition(bx, scene.player.y - scene.player.displayHeight - 40);
  }
});


    if (autoHideMs > 0) {
      scene.time.delayedCall(autoHideMs, ()=>{
        scene.tweens.add({
          targets:bubble, alpha:0, duration:220,
          onComplete:()=>{
            if (bubble._follow) bubble._follow.remove(false);
            bubble.destroy(true);
            if (scene._playerBubble === bubble) scene._playerBubble = null;
          }
        });
      });
    }
  }

  function _s4ShowNpcBubble(scene, text){
    const s4 = scene._s4; if (!s4) return;
    if (s4.npcBubble) {
      if (s4.npcBubble._follow) s4.npcBubble._follow.remove(false);
      s4.npcBubble.destroy(true);
    }

    const npcW = _worldPos(scene, s4.container, s4.npc);
    const above = npcW.y - (s4.npc.displayHeight * s4.container.scaleY) - 16;

    const bubble = scene.add.text(
      npcW.x, above, text,
      { fontFamily:"monospace", fontSize:14, color:"#ffffff", backgroundColor:"#000000", align:"center" }
    ).setOrigin(0.5,1).setDepth(6500).setAlpha(0);

    s4.npcBubble = bubble;

    scene.tweens.add({ targets:bubble, alpha:1, duration:200 });
bubble._follow = scene.time.addEvent({
  delay:16, loop:true, callback:()=>{
    const p = _worldPos(scene, s4.container, s4.npc);
    const y = p.y - (s4.npc.displayHeight * s4.container.scaleY) - 16;
    const bx = _clampToViewX(scene, p.x);
    bubble.setPosition(bx, y);
  }
});


    scene.time.delayedCall(1800, ()=>{
      scene.tweens.add({
        targets:bubble, alpha:0, duration:250,
        onComplete:()=>{
          if (bubble._follow) bubble._follow.remove(false);
          bubble.destroy(true);
          if (s4 && s4.npcBubble === bubble) s4.npcBubble = null;
        }
      });
    });
  }

  /* Spotify-like widget + start song (Scene 4) */
  function _s4ShowSpotifyWidget(scene, onPlay){
    const s4 = scene._s4; if (!s4) return;

    if (s4.ui) s4.ui.destroy(true);
    if (s4.uiFollow) { s4.uiFollow.remove(false); s4.uiFollow = null; }

    const ui = scene.add.container(0,0).setDepth(6000);
    s4.ui = ui;

    const SONG_TITLE = "When it's time – Green Day";
    const OFFSET_Y = 0;

    const computePos = ()=>{
      const baseTex = scene.textures.get('scene4');
      const src = baseTex ? baseTex.getSourceImage() : null;
      const sx = s4.container.scaleX ?? 1;
      const sy = s4.container.scaleY ?? 1;

      const centerX = s4.container.x;
      let centerY = s4.container.y;
      if (src) {
        const topY = s4.container.y - (src.height * sy);
        centerY = topY + (src.height * sy) * 0.5;
      }
      return { x: centerX, y: centerY + OFFSET_Y };
    };
    const p = computePos();

    const CARD_W = 320, CARD_H = 72;
    const card = scene.add.rectangle(p.x, p.y, CARD_W, CARD_H, 0x121212, 0.96)
      .setOrigin(0.5)
      .setStrokeStyle(2, 0x1db954, 0.9);
    ui.add(card);

    const album = scene.add.rectangle(p.x - CARD_W/2 + 12 + 24, p.y, 48, 48, 0x222222, 1)
      .setOrigin(0.5).setStrokeStyle(1, 0x444444, 1);
    ui.add(album);

    const title = scene.add.text(
      p.x - CARD_W/2 + 12 + 24 + 32, p.y - 10,
      SONG_TITLE,
      { fontFamily:'monospace', fontSize:14, color:'#ffffff', wordWrap:{ width: CARD_W - 140 } }
    ).setOrigin(0,0.5);
    ui.add(title);

    const btnW=80, btnH=28;
    const playBg = scene.add.rectangle(p.x + CARD_W/2 - btnW/2 - 12, p.y + 12, btnW, btnH, 0x1db954, 1)
      .setOrigin(0.5);
    const playTx = scene.add.text(playBg.x, playBg.y, '▶ Play', {
      fontFamily:'monospace', fontSize:14, color:'#000000'
    }).setOrigin(0.5);
    ui.add(playBg); ui.add(playTx);

    [card, album, title, playBg, playTx].forEach(el=>{
      el.setInteractive({ useHandCursor:true });
      el.on('pointerdown', async ()=>{
        try{
          if (scene.sound.locked) scene.sound.unlock();
          if (scene.sound.context && scene.sound.context.state === 'suspended'){
            await scene.sound.context.resume();
          }
        }catch(e){}
        if (onPlay) onPlay();
      });
    });

    s4.uiFollow = scene.time.addEvent({
      delay:16, loop:true, callback:()=>{
        const np = computePos();
        card.setPosition(np.x, np.y);
        album.setPosition(np.x - CARD_W/2 + 12 + 24, np.y);
        title.setPosition(np.x - CARD_W/2 + 12 + 24 + 32, np.y - 10);
        playBg.setPosition(np.x + CARD_W/2 - btnW/2 - 12, np.y + 12);
        playTx.setPosition(playBg.x, playBg.y);
      }
    });
  }

  function _s4StartSong(scene){
    const s4 = scene._s4;
    if (!s4) return;

    if (GameState.bgm && GameState.bgm.isPlaying) GameState.bgm.stop();
    if (scene.ambBirds && scene.ambBirds.isPlaying) scene.ambBirds.stop();
    if (scene.ambAtmo  && scene.ambAtmo.isPlaying)  scene.ambAtmo.stop();

    if (!scene.cache.audio.exists('scene4_song')) {
      console.warn('[Scene4] Missing audio key "scene4_song" (/assets/audio/greenday.mp3)');
      return;
    }
    if (!s4.song) {
      s4.song = scene.sound.add('scene4_song', { volume:0.20, loop:true });
    }

    if (s4.ui) { s4.ui.destroy(true); s4.ui=null; }
    if (s4.uiFollow) { s4.uiFollow.remove(false); s4.uiFollow = null; }
    if (s4.bubble) { if (s4.bubble._follow) s4.bubble._follow.remove(false); s4.bubble.destroy(true); s4.bubble=null; }

    s4.song.play({ seek: 0 });
    s4.songPlaying = true;
    GameState.bgm = s4.song;

    // Lock until dialog finishes
    scene._controlsLocked = true;
    s4.dialogTimers ||= [];

    const t1 = scene.time.delayedCall(4000, () => { _s4ShowNpcBubble(scene, "¡Me encanta! ❤️"); });
    const t2 = scene.time.delayedCall(5200, () => { _s4ShowBubble(scene, "Te amo"); });
    const t3 = scene.time.delayedCall(7200, () => { _s4ShowNpcBubble(scene, "Yo también te amo"); });
    const t4 = scene.time.delayedCall(9000, () => { scene._controlsLocked = false; });

    s4.dialogTimers.push(t1, t2, t3, t4);
  }

  /* ===================== ZONES (mini-scenes) ===================== */
  const ZONE_DEFS = {
    /* ------------ Scene 1 (with birds & hint) ------------ */
    1: {
      manifest: {
        images: [
          { key:'scene1', path:'/assets/scenes/scene1/scene1.png' },
          { key:'s1_gorrion', path:'/assets/scenes/scene1/extra/gorrion.png' },
          { key:'s1_gorrion_jump', path:'/assets/scenes/scene1/extra/gorrion_jump.png' },
          { key:'s1_gorriones', path:'/assets/scenes/scene1/extra/gorriones.png' }
        ]
      },
      build(scene, container){
        const who = GameState.character || 'joaquin';

        container.add(scene.add.image(80, -260, 's1_gorriones')
          .setOrigin(0.5,1).setScale(0.070).setDepth(1));

        const spar = scene.add.sprite(20,-10,'s1_gorrion')
          .setOrigin(0.5,1).setScale(0.080).setDepth(2);
        container.add(spar);

        let baseX = 20, t=0, phase="idle";
        let idleLeft = Phaser.Math.Between(1500, 3000);
        const dirPattern=[1,1,-1,1,-1,-1]; let patIdx=0;

        const ev = scene.time.addEvent({
          delay:16, loop:true, callback:()=>{
            if (!spar.active) return;
            if (phase==="idle") {
              idleLeft -= 16;
              if (idleLeft <= 0) { phase="hop"; t=0; spar.setTexture('s1_gorrion_jump'); }
            } else {
              t+=16;
              const p=Math.min(1,t/420); const eased=p*p*(3-2*p);
              const dir=dirPattern[patIdx];
              const endX=baseX+dir*12;
              spar.x=baseX+(endX-baseX)*eased;
              spar.y=-10 - (18)*4*p*(1-p);
              if (p>=1){ baseX=endX; spar.x=endX; spar.y=-10; spar.setTexture('s1_gorrion');
                patIdx=(patIdx+1)%dirPattern.length; phase="idle"; idleLeft=Phaser.Math.Between(1500, 3000); }
            }
          }
        });
        this._timers = [ev];

        const otherImgKey = (who === 'sofia') ? 'joaquin_idle' : 'sofia_idle';
        container.add(scene.add.image(180,-10, otherImgKey).setOrigin(0.5,1).setScale(0.5).setDepth(1));
      },

      enter(scene){
        if (GameState.sound) {
          if (scene.ambBirds && !scene.ambBirds.isPlaying) scene.ambBirds.play();
          if (scene.ambAtmo  && !scene.ambAtmo.isPlaying)  scene.ambAtmo.play();
        }
      },

      leave(scene){
        if (scene.thoughtBubble) scene.tweens.add({ targets: scene.thoughtBubble, alpha:0, duration:250 });
        (this._timers || []).forEach(t => { try{ t.remove(false); }catch{} });
        this._timers = [];

        if (scene.ambBirds && scene.ambBirds.isPlaying) scene.ambBirds.stop();
        if (scene.ambAtmo  && scene.ambAtmo.isPlaying)  scene.ambAtmo.stop();
      },

      update(scene){
        const b = scene._zoneBounds(1).center;
        const inRange = (scene.player.x >= b - 80 && scene.player.x <= b + 80);

        if (inRange && !scene._bubbleVisible) {
          scene._bubbleVisible = true;
          scene.tweens.add({ targets: scene.thoughtBubble, alpha:1, duration:400, ease:'Sine.easeInOut' });
        }
        if (!inRange && scene._bubbleVisible) {
          scene._bubbleVisible = false;
          scene.tweens.add({ targets: scene.thoughtBubble, alpha:0, duration:300, ease:'Sine.easeInOut' });
        }
      },
    },

    /* ------------ Scene 2 (music corner) ------------ */
    2: {
      manifest: {
        images: [
          { key:'scene3',      path:'/assets/scenes/scene3/scene3.png' },
          { key:'s3_extras1',  path:'/assets/scenes/scene3/extra/extras_musica.png' },
          { key:'s3_extras2',  path:'/assets/scenes/scene3/extra/extras_musica2.png' },
          { key:'s2_singer_sheet', path:'/assets/sofia/scene2/sofia_canta.png' },
          { key:'joaquin_guitar1', path:'/assets/joaquin/scene2/joaquin_guitar.png' },
          { key:'joaquin_guitar2', path:'/assets/joaquin/scene2/joaquin_guitar2.png' },
          { key:'joaquin_guitar3', path:'/assets/joaquin/scene2/joaquin_guitar3.png' },
        ]
      },

      _showPlayerBubble(scene, text, autoHideMs = 1800){
        if (this._pBubble) {
          try { this._pBubble._follow?.remove(false); } catch(_) {}
          this._pBubble.destroy(true);
          this._pBubble = null;
        }
        const bubble = scene.add.text(
          scene.player.x,
          scene.player.y - scene.player.displayHeight - 40,
          text,
          { fontFamily:'monospace', fontSize:14, color:'#ffffff', backgroundColor:'#000000', align:'center' }
        ).setOrigin(0.5,1).setDepth(6500).setAlpha(0);
        this._pBubble = bubble;

        scene.tweens.add({ targets:bubble, alpha:1, duration:200 });
        bubble._follow = scene.time.addEvent({
          delay:16, loop:true, callback:()=>{
            if (!bubble.active) return;
            bubble.setPosition(scene.player.x, scene.player.y - scene.player.displayHeight - 40);
          }
        });

        if (autoHideMs > 0){
          scene.time.delayedCall(autoHideMs, ()=>{
            scene.tweens.add({
              targets:bubble, alpha:0, duration:220,
              onComplete:()=>{
                try { bubble._follow?.remove(false); } catch(_) {}
                bubble.destroy(true);
                if (this._pBubble === bubble) this._pBubble = null;
              }
            });
          });
        }
      },

      build(scene, container){
        const animKey = 's3_extras_anim';
        if (!scene.anims.exists(animKey)) {
          scene.anims.create({
            key: animKey,
            frames: [{ key:'s3_extras1' }, { key:'s3_extras2' }],
            frameRate: 3, repeat: -1, yoyo: true
          });
        }
        container.add(
          scene.add.sprite(-320, -10, 's3_extras1')
            .setOrigin(0.5,1).setScale(0.30).setDepth(2).play(animKey)
        );

        const who = GameState.character || 'joaquin';
        const other = (who === 'sofia') ? 'joaquin' : 'sofia';
        let npcRef = null;

        if (other === 'sofia') {
          const img = scene.textures.get('s2_singer_sheet')?.getSourceImage();
          if (img){
            const framesAcross = 3;
            const frameWidth  = Math.round(img.width / framesAcross);
            const frameHeight = img.height;

            if (!scene.textures.exists('s2_singer')){
              scene.textures.addSpriteSheet('s2_singer', img, {
                frameWidth, frameHeight, endFrame: framesAcross - 1
              });
            }
            if (!scene.anims.exists('s2_singer_anim')){
              scene.anims.create({
                key:'s2_singer_anim',
                frames: scene.anims.generateFrameNumbers('s2_singer', { frames: [0,1,2,1] }),
                frameRate: 3, repeat: -1
              });
            }
            npcRef = scene.add.sprite(-60, 80, 's2_singer', 0)
              .setOrigin(0.5,1).setScale(0.40).setDepth(3).play('s2_singer_anim');
            container.add(npcRef);
            scene.tweens.add({ targets:npcRef, y:'-=4', duration:10000, yoyo:true, repeat:-1, ease:'Sine.easeInOut' });
          }
        }

        if (other === 'joaquin') {
          const hasJ1 = scene.textures.exists('joaquin_guitar1');
          const hasJ2 = scene.textures.exists('joaquin_guitar2');
          const hasJ3 = scene.textures.exists('joaquin_guitar3');
          const frames = [
            hasJ1 && { key:'joaquin_guitar1' },
            hasJ2 && { key:'joaquin_guitar2' },
            hasJ3 && { key:'joaquin_guitar3' },
          ].filter(Boolean);

          if (frames.length){
            if (frames.length === 1) frames.push(frames[0]);
            if (!scene.anims.exists('joaquin_guitar_anim')){
              scene.anims.create({ key:'joaquin_guitar_anim', frames, frameRate:3, repeat:-1, yoyo:true });
            }
            npcRef = scene.add.sprite(220, -80, frames[0].key)
              .setOrigin(0.5,1).setScale(0.60).setDepth(3).setFlipX(true).play('joaquin_guitar_anim');
            container.add(npcRef);
          }
        }

        scene._s2 = {
          container,
          npcRef,
          npcRole: other,
          triggerRadius: 110,
          spokeOnce: false
        };
      },

      enter(scene){
        if (!scene._s2) return;
        this._pBubble && this._pBubble.destroy(true);
        this._pBubble = null;
        scene._s2.spokeOnce = false;
      },

      leave(scene){
        this._pBubble && this._pBubble.destroy(true);
        this._pBubble = null;
        scene._s2 = null;
      },

      update(scene){
        const s2 = scene._s2; if (!s2 || !s2.npcRef) return;

        const npcW = _worldPos(scene, s2.container, s2.npcRef);
        s2.npcRef.setFlipX(scene.player.x < npcW.x);

        const dx = Math.abs(scene.player.x - npcW.x);
        if (!s2.spokeOnce && dx <= s2.triggerRadius) {
          s2.spokeOnce = true;
          const playerLine =
            (s2.npcRole === 'joaquin') ? 'Qué bonito toca la guitarra'
                                       : 'Qué lindo canta';
          this._showPlayerBubble(scene, playerLine, 1800);
        }
      },
    },

    /* ------------ Scene 3 (follower NPC inside bounds) ------------ */
    3: {
      manifest: { images:[ { key:'scene2', path:'/assets/scenes/scene2/scene2.png' } ] },
      build(scene, container){
        const baseImg = container.list.find(o => o.texture?.key?.startsWith('scene'));
        if (!baseImg) return;
        const pad = 12;
        const b = baseImg.getBounds();
        const left  = b.left  + pad;
        const right = b.right - pad;

        scene._npc3_bounds     = { left, right };
        scene._npc3_waitLeftX  = left;
        scene._npc3_waitRightX = right;
        scene._npc3_followGap  = 30;
        scene._npc3_lerp       = 0.20;

        const who   = GameState.character || 'joaquin';
        const other = (who === 'sofia') ? 'joaquin' : 'sofia';
        scene._npc3_other   = other;
        scene._npc3_walkKey = `npc3_walk_${other}`;

        if (!scene.anims.exists(scene._npc3_walkKey)) {
          scene.anims.create({
            key: scene._npc3_walkKey,
            frames: [1,2,3,4,5,6].map(i => ({ key: `${other}_walk${i}` })),
            frameRate: 12,
            repeat: -1
          });
        }

        if (!scene._npc3) {
          scene._npc3 = scene.add
            .sprite(scene._npc3_waitLeftX, scene.railY, `${other}_idle`)
            .setOrigin(0.5, 1)
            .setScale(0.2)
            .setDepth(999)
            .setFlipX(false);
          scene._npc3_mode = 'left_wait';
        } else {
          scene._npc3.setDepth(999).setScale(0.2);
          scene._npc3.x = Phaser.Math.Clamp(scene._npc3.x, left, right);
        }
      },

      enter(scene){
        const npc = scene._npc3, lim = scene._npc3_bounds;
        if (!npc || !lim) return;
        const px = scene.player.x;

        if (px >= lim.left && px <= lim.right) {
          const gap = scene.player.flipX ? -scene._npc3_followGap : scene._npc3_followGap;
          npc.x = Phaser.Math.Clamp(px + gap, lim.left, lim.right);
          npc.setFlipX(scene.player.flipX);
          scene._npc3_mode = 'follow';
          scene.isMoving ? npc.play(scene._npc3_walkKey, true)
                         : npc.setTexture(`${scene._npc3_other}_idle`);
        } else {
          if (px <  lim.left) { npc.x = scene._npc3_waitLeftX;  npc.setFlipX(false);  scene._npc3_mode = 'left_wait'; }
          if (px >  lim.right){ npc.x = scene._npc3_waitRightX; npc.setFlipX(true);   scene._npc3_mode = 'right_wait'; }
          npc.stop().setTexture(`${scene._npc3_other}_idle`);
        }
      },

      leave(scene){
        const npc = scene._npc3, lim = scene._npc3_bounds;
        if (npc && lim){
          const px = scene.player.x;
          if (px <= lim.left)  { npc.x = scene._npc3_waitLeftX;  npc.setFlipX(false);  scene._npc3_mode = 'left_wait'; }
          if (px >= lim.right) { npc.x = scene._npc3_waitRightX; npc.setFlipX(true);   scene._npc3_mode = 'right_wait'; }
          npc.stop().setTexture(`${scene._npc3_other}_idle`);
        }
      },

      update(scene){
        const npc = scene._npc3, lim = scene._npc3_bounds;
        if (!npc || !lim) return;

        const px = scene.player.x;

        if (px < lim.left) {
          scene._npc3_mode = 'left_wait';
          npc.x = scene._npc3_waitLeftX;
          npc.setFlipX(false);
          npc.stop().setTexture(`${scene._npc3_other}_idle`);
          return;
        }
        if (px > lim.right) {
          scene._npc3_mode = 'right_wait';
          npc.x = scene._npc3_waitRightX;
          npc.setFlipX(true);
          npc.stop().setTexture(`${scene._npc3_other}_idle`);
          return;
        }

        scene._npc3_mode = 'follow';
        const gap     = scene.player.flipX ? -scene._npc3_followGap : scene._npc3_followGap;
        const targetX = Phaser.Math.Clamp(px + gap, lim.left, lim.right);

        npc.x = Phaser.Math.Linear(npc.x, targetX, scene._npc3_lerp);
        npc.setFlipX(scene.player.flipX);

        if (scene.isMoving) {
          if (!npc.anims.currentAnim || npc.anims.currentAnim.key !== scene._npc3_walkKey) {
            npc.play(scene._npc3_walkKey, true);
          }
          const pf = scene.player.anims.currentFrame, na = npc.anims.currentAnim;
          if (pf && na && na.frames && na.frames[pf.index]) npc.anims.setCurrentFrame(na.frames[pf.index]);
        } else {
          npc.stop().setTexture(`${scene._npc3_other}_idle`);
        }
      },
    },

    /* ------------ Scene 4 (bench + song) ------------ */
    4: {
      manifest: {
        images: [
          { key: "scene4",         path: "/assets/scenes/scene4/scene4.png" },
          { key: "s4_bench",       path: "/assets/scenes/scene4/extra/bench.png" },
          { key: "s4_npc_sofia",   path: "/assets/sofia/casual/sofia_standing.png" },
          { key: "s4_npc_joaquin", path: "/assets/joaquin/casual/joaquin_standing.png" }
        ]
      },

      build(scene, container){
        const baseSrc = scene.textures.get("scene4").getSourceImage();
        const baseW   = baseSrc.width;

        const BENCH_REL_WIDTH = 0.250;
        const benchTexW  = scene.textures.get("s4_bench").getSourceImage().width;
        const benchScale = (BENCH_REL_WIDTH * baseW) / benchTexW;

        const bench = scene.add.sprite(0, -8, "s4_bench")
          .setOrigin(0.5, 1)
          .setScale(benchScale)
          .setDepth(3);
        container.add(bench);

        const who   = GameState.character || 'joaquin';
        const other = (who === 'sofia') ? 'joaquin' : 'sofia';
        const npcKey = (other === 'sofia') ? 's4_npc_sofia' : 's4_npc_joaquin';

        const NPC_REL_WIDTH = 0.080;
        const npcTexW  = scene.textures.get(npcKey).getSourceImage().width;
        const npc = scene.add.sprite(0, 0, npcKey)
          .setOrigin(0.1, 1)
          .setScale((NPC_REL_WIDTH * baseW) / npcTexW)
          .setDepth(4);
        container.add(npc);

        scene._s4 = {
          popupTimer: null,
          npcBubble: null,
          container,
          npc,
          stopGap: 10,
          triggerRadius: 30,
          ui: null,
          uiFollow: null,
          bubble: null,
          song: null,
          songPlaying: false,
          locking: false,
          prevPlayerScale: null,
        };
      },

      leave(scene){
        if (scene._s4?.ui) scene._s4.ui.destroy(true);
        if (scene._s4?.uiFollow) { scene._s4.uiFollow.remove(false); scene._s4.uiFollow = null; }
        if (scene._s4?.popupTimer) { try { scene._s4.popupTimer.remove(false); } catch(_){} scene._s4.popupTimer = null; }
        if (scene._s4?.bubble) {
          if (scene._s4.bubble._follow) scene._s4.bubble._follow.remove(false);
          scene._s4.bubble.destroy(true);
        }
        if (scene._s4?.dialogTimers && Array.isArray(scene._s4.dialogTimers)) {
          scene._s4.dialogTimers.forEach(t => { try { t.remove(false); } catch(_){} });
        }
        if (scene._s4?.npcBubble) {
          if (scene._s4.npcBubble._follow) scene._s4.npcBubble._follow.remove(false);
          scene._s4.npcBubble.destroy(true);
        }

        if (scene._s4?.song && scene._s4.song.isPlaying) scene._s4.song.stop();

        if (GameState.bgm === scene._s4?.song) {
          GameState.bgm = scene.sound.add('bgm', { loop:true, volume: 0.10 });
          if (GameState.sound) { try { GameState.bgm.play(); } catch(_) {} }
        }

        if (scene._s4?.prevPlayerScale) {
          scene.player.setScale(scene._s4.prevPlayerScale.x, scene._s4.prevPlayerScale.y);
        }

        scene._s4 = null;
        scene._controlsLocked = false;
        scene._lockStopX = null;
      },

      update(scene){
        const s4 = scene._s4;
        if (!s4) return;

        const npcW = _worldPos(scene, s4.container, s4.npc);
        const px   = scene.player.x;
        const dx   = Math.abs(px - npcW.x);

        s4.npc.setFlipX(px < npcW.x);
        if (s4.songPlaying) return;

        const near = dx <= s4.triggerRadius;
        if (near && !s4.locking) {
          s4.locking = true;
          scene._controlsLocked = true;
          scene._lockStopX = (px < npcW.x) ? (npcW.x - s4.stopGap) : (npcW.x + s4.stopGap);

          _s4ShowNpcBubble(scene, "Quiero mostrarte esta canción");

          if (s4.popupTimer) { try { s4.popupTimer.remove(false); } catch(_){} }
          s4.popupTimer = scene.time.delayedCall(3000, () => {
            if (s4 && s4.locking && !s4.ui && !s4.songPlaying) {
              _s4ShowSpotifyWidget(scene, () => _s4StartSong(scene));
            }
          });
        }

        if (!near && s4.locking) {
          s4.locking = false;
          scene._controlsLocked = false;
          scene._lockStopX = null;

          if (s4.popupTimer) { try { s4.popupTimer.remove(false); } catch(_){} s4.popupTimer = null; }
          if (s4.bubble) scene.tweens.add({
            targets: s4.bubble, alpha: 0, duration: 250,
            onComplete: () => {
              if (s4.bubble?._follow) s4.bubble._follow.remove(false);
              s4.bubble?.destroy(true);
              s4.bubble = null;
            }
          });
          if (s4.ui) { s4.ui.destroy(true); s4.ui = null; }
          if (s4.uiFollow) { s4.uiFollow.remove(false); s4.uiFollow = null; }
        }
      },
    },

    /* ------------ Scene 5 (Locky follower) ------------ */
    5: {
      manifest: {
        images: [
          { key: 'scene5',         path: '/assets/scenes/scene5/scene5.png' },
          { key: 's4_npc_sofia',   path: '/assets/sofia/casual/sofia_standing.png' },
          { key: 's4_npc_joaquin', path: '/assets/joaquin/casual/joaquin_standing.png' },
          { key: 's5_loky_sit',  path: '/assets/loky/loky_sitting.png' },
          { key: 'loky_walk1',   path: '/assets/loky/loky_walk1.png' },
          { key: 'loky_walk2',   path: '/assets/loky/loky_walk2.png' },
          { key: 'loky_walk3',   path: '/assets/loky/loky_walk3.png' },
          { key: 'loky_walk4',   path: '/assets/loky/loky_walk4.png' }
        ]
      },

      build(scene, container){
        const baseImg = scene.textures.get('scene5').getSourceImage();
        const baseW   = baseImg.width;

        const NPC_REL_W        = 0.085;
        const LOKY_REL_W       = 0.045;
        const FOLLOW_GAP       = 28;
        const LERP_FOLLOW      = 0.20;
        const APPROACH_SPEED   = 120;
        const MOVE_EPS         = 0.02;

        const TRIGGER_RADIUS   = 50;
        const STOP_GAP         = 14;

        const who   = GameState.character || 'joaquin';
        const other = (who === 'sofia') ? 'joaquin' : 'sofia';
        const npcKey = (other === 'sofia') ? 's4_npc_sofia' : 's4_npc_joaquin';

        const npcTexW = scene.textures.get(npcKey).getSourceImage().width;
        const npc = scene.add.sprite(0, 0, npcKey)
          .setOrigin(0.5, 1)
          .setScale((NPC_REL_W * baseW) / npcTexW)
          .setDepth(4);
        container.add(npc);

        scene.tweens.add({ targets: npc, y: '-=3', duration: 2200, yoyo: true, repeat: -1, ease: 'Sine.easeInOut' });

        const sitKey = scene.textures.exists('s5_loky_sit') ? 's5_loky_sit' : 'loky_walk1';
        const lokyW  = scene.textures.get(sitKey).getSourceImage().width;
        const loky   = scene.add.sprite(-baseW * 0.35, 0, sitKey)
          .setOrigin(0.5, 1)
          .setScale((LOKY_REL_W * baseW) / lokyW)
          .setDepth(3);
        container.add(loky);

        const frames = ['loky_walk1','loky_walk2','loky_walk3','loky_walk4'].filter(k => scene.textures.exists(k));
        let walkKey = null;
        if (frames.length >= 2 && !scene.anims.exists('loky_walk_anim')) {
          scene.anims.create({ key: 'loky_walk_anim', frames: frames.map(k => ({ key:k })), frameRate: 12, repeat: -1 });
          walkKey = 'loky_walk_anim';
        } else if (scene.anims.exists('loky_walk_anim')) {
          walkKey = 'loky_walk_anim';
        }

        const sx = container.scaleX || 1;
        const halfWorld = (baseW * sx) * 0.5;
        const leftBoundWorld  = container.x - halfWorld;
        const rightBoundWorld = container.x + halfWorld;

        scene._s5 = {
          container,
          npc,
          loky,
          sitKey,
          walkKey,
          followGap: FOLLOW_GAP,
          lerp: LERP_FOLLOW,
          approachSpeed: APPROACH_SPEED,
          moveEps: MOVE_EPS,
          leftBoundWorld,
          rightBoundWorld,
          stopGap: STOP_GAP,
          triggerRadius: TRIGGER_RADIUS,
          didIntro: false,
          _dlg1: null,
          _dlg2: null,
          loopEvt: null,
          mode: 'idle',
          promoted: false,
        };
      },

      enter(scene){
        const s5 = scene._s5; if (!s5) return;

        const baseImg = scene.textures.get('scene5').getSourceImage();
        const sx = s5.container.scaleX || 1;
        const halfWorld = (baseImg.width * sx) * 0.5;
        s5.leftBoundWorld  = s5.container.x - halfWorld;
        s5.rightBoundWorld = s5.container.x + halfWorld;

        if (!s5.promoted) {
          const sxC = s5.container.scaleX || 1;
          const worldX = s5.container.x + s5.loky.x * sxC;
          s5.container.remove(s5.loky);
          s5.loky.x = worldX;
          s5.loky.y = scene.railY;
          s5.loky.setScale(s5.loky.scaleX * sxC, s5.loky.scaleY * sxC);
          scene.add.existing(s5.loky);
          s5.promoted = true;
        }

        s5.loky.setTexture(s5.sitKey);
        s5.mode = 'idle';
        s5.didIntro = false;
        if (s5._dlg1) { try{s5._dlg1.remove(false);}catch{} s5._dlg1=null; }
        if (s5._dlg2) { try{s5._dlg2.remove(false);}catch{} s5._dlg2=null; }

        if (s5.loopEvt) { try { s5.loopEvt.remove(false); } catch(_) {} }
        s5.loopEvt = scene.time.addEvent({
          delay: 16,
          loop: true,
          callback: () => {
            const npcW = _worldPos(scene, s5.container, s5.npc);
            s5.npc.setFlipX(scene.player.x < npcW.x);

            if (!s5.didIntro) {
              const nearNpc = Math.abs(scene.player.x - npcW.x) <= s5.triggerRadius;
              if (nearNpc) {
                s5.didIntro = true;
                scene._controlsLocked = true;
                scene._lockStopX = (scene.player.x < npcW.x) ? (npcW.x - s5.stopGap) : (npcW.x + s5.stopGap);
                scene._s4 = { container: s5.container, npc: s5.npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };

                const playerIsJoaquin = (GameState.character || 'joaquin') === 'joaquin';
                if (playerIsJoaquin) { _s4ShowBubble(scene, "¿Ahora tenemos un perrito!?"); }
                else { _s4ShowNpcBubble(scene, "¿Ahora tenemos un perrito!?"); }

                s5._dlg1 = scene.time.delayedCall(1200, () => {
                  if (playerIsJoaquin) { _s4ShowNpcBubble(scene, "Te presento a Locky."); }
                  else { _s4ShowBubble(scene, "Te presento a Locky."); }
                });

                s5._dlg2 = scene.time.delayedCall(2400, () => {
                  scene._controlsLocked = false;
                  scene._lockStopX = null;
                });
              }
            }

            const inside = (scene.player.x >= s5.leftBoundWorld && scene.player.x <= s5.rightBoundWorld);
            if (!inside) {
              const atLeft = scene.player.x < s5.leftBoundWorld;
              s5.loky.x = atLeft ? s5.leftBoundWorld : s5.rightBoundWorld;
              if (s5.loky.anims?.isPlaying) s5.loky.stop();
              s5.loky.setTexture(s5.sitKey);
              s5.loky.setFlipX(scene.player.x < s5.loky.x);
              s5.mode = 'idle';
              return;
            }

            if (s5.mode === 'idle') s5.mode = 'approachOnce';
            const gap      = s5.followGap;
            const targetX  = scene.player.x + (scene.player.flipX ? -gap : gap);
            const desiredX = Phaser.Math.Clamp(targetX, s5.leftBoundWorld, s5.rightBoundWorld);

            s5.loky.setFlipX(desiredX < s5.loky.x);

            const prevX = s5.loky.x;
            let nextX   = prevX;
            if (s5.mode === 'approachOnce') {
              const step = s5.approachSpeed * (16/1000);
              const delta = Phaser.Math.Clamp(desiredX - prevX, -step, step);
              nextX = prevX + delta;
            } else {
              nextX = Phaser.Math.Linear(prevX, desiredX, s5.lerp);
            }

            const moved = Math.abs(nextX - prevX) > s5.moveEps;
            if (moved) {
              if (s5.walkKey && (!s5.loky.anims.currentAnim || s5.loky.anims.currentAnim.key !== s5.walkKey)) {
                s5.loky.play(s5.walkKey, true);
              }
              if (scene.isMoving && scene.player.anims?.currentAnim && s5.loky.anims?.currentAnim) {
                const pf = scene.player.anims.currentFrame, da = s5.loky.anims.currentAnim;
                if (pf && da && da.frames && da.frames.length > 0) {
                  const idx = pf.index % da.frames.length;
                  if (da.frames[idx]) s5.loky.anims.setCurrentFrame(da.frames[idx]);
                }
              }
            } else {
              if (s5.loky.anims?.isPlaying) s5.loky.stop();
              s5.loky.setTexture(s5.sitKey);
            }

            s5.loky.x = nextX;

            if (s5.mode === 'approachOnce' && Math.abs(desiredX - nextX) <= (s5.moveEps * 2)) {
              s5.mode = 'follow';
            }
          }
        });
      },

      leave(scene){
        const s5 = scene._s5; if (!s5) return;
        if (s5._dlg1) { try{s5._dlg1.remove(false);}catch{} s5._dlg1 = null; }
        if (s5._dlg2) { try{s5._dlg2.remove(false);}catch{} s5._dlg2 = null; }
        if (s5.loopEvt) { try{s5.loopEvt.remove(false);}catch{} s5.loopEvt = null; }

        s5.loky.x = Phaser.Math.Clamp(s5.loky.x, s5.leftBoundWorld, s5.rightBoundWorld);
        if (s5.loky.anims?.isPlaying) s5.loky.stop();
        s5.loky.setTexture(s5.sitKey);

        scene._controlsLocked = false;
        scene._lockStopX = null;
        scene._s5 = null;
      },

      update(){},
    },

    /* ------------ Scene 6 (seated toast + drone) ------------ */
    6: {
      manifest: {
        images: [
          { key: 'scene6',              path: '/assets/scenes/scene6/scene6.png' },
          { key: 's6_sofia_seated',     path: '/assets/sofia/casual/sofia_seated.png'  },
          { key: 's6_sofia_seated2',    path: '/assets/sofia/casual/sofia_seated2.png' },
          { key: 's6_sofia_seated3',    path: '/assets/sofia/casual/sofia_seated3.png' },
          { key: 's6_joaquin_seated',   path: '/assets/joaquin/casual/joaquin_seated.png'  },
          { key: 's6_drone', path: '/assets/scenes/scene6/extra/drone.png' }
        ]
      },

      build(scene, container){
        const SOFIA_SEAT_REL_X =  0.30;
        const SOFIA_SEAT_REL_Y = -90;
        const NPC_REL_W        =  0.140;

        const TRIGGER_RADIUS   = 100;
        const STOP_GAP         =  18;

        const DRONE_REL_W  = 0.100;
        const DRONE_RX_REL = 0.35;
        const DRONE_RY_REL = 0.18;
        const DRONE_SPEED  = 0.20;
        const DRONE_CX_REL = 0.05;
        const DRONE_CY_REL = -0.28;

        const baseTex = scene.textures.get('scene6');
        const src     = baseTex.getSourceImage();
        const baseW   = src.width;

        const playerIsSofia = (GameState.character || 'joaquin') === 'sofia';
        const joaquinSet = ['s6_joaquin_seated'];
        const sofiaSet   = ['s6_sofia_seated','s6_sofia_seated2','s6_sofia_seated3'];

        const hasJoaquin = joaquinSet.every(k => scene.textures.exists(k));
        const npcFrames  = playerIsSofia && hasJoaquin ? joaquinSet : sofiaSet;

        const toastKey = `s6_npc_toast_${npcFrames[0]}`;
        if (!scene.anims.exists(toastKey)) {
          scene.anims.create({
            key: toastKey,
            frames: [
              { key: npcFrames[0] },
              { key: npcFrames[1] },
              { key: npcFrames[2] },
              { key: npcFrames[1] },
              { key: npcFrames[0] },
            ],
            frameRate: 7,
            repeat: 0
          });
        }

        const npcBaseW = scene.textures.get(npcFrames[0]).getSourceImage().width;
        const npcScale = (NPC_REL_W * baseW) / npcBaseW;

        const seatLocalX = baseW * SOFIA_SEAT_REL_X;
        const seatLocalY = SOFIA_SEAT_REL_Y;

        const npc = scene.add.sprite(seatLocalX, seatLocalY, npcFrames[0])
          .setOrigin(0.5, 1)
          .setScale(npcScale)
          .setDepth(5)
          .setFlipX(true);
        container.add(npc);

        const dImgW   = scene.textures.get('s6_drone').getSourceImage().width;
        const dScale  = (DRONE_REL_W * baseW) / dImgW;

        const drone = scene.add
          .sprite(0, 0, 's6_drone')
          .setOrigin(0.5)
          .setScale(dScale)
          .setDepth(6);
        container.add(drone);

        scene._s6 = {
          container,
          npc,
          npcFrames,
          toastKey,
          triggerRadius: TRIGGER_RADIUS,
          stopGap: STOP_GAP,
          timers: [],
          locking: false,
          doneOnce: false,
          npcWorldX(){
            const sx = container.scaleX || 1;
            return container.x + seatLocalX * sx;
          },
          npcWorldY(){
            const sy = container.scaleY || 1;
            return scene.railY + seatLocalY * sy;
          },
          drone,
          drone_t: Math.random() * Math.PI * 2,
          drone_speed: DRONE_SPEED,
          drone_rx: baseW * DRONE_RX_REL,
          drone_ry: baseW * DRONE_RY_REL,
          drone_cx: baseW * DRONE_CX_REL,
          drone_cy: baseW * DRONE_CY_REL,
        };

        scene._s4 = { container, npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };
        scene._s4_from6 = true;
      },

      enter(scene){
        const s6 = scene._s6; if (!s6) return;
        scene._s4 = { container: s6.container, npc: s6.npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };
        scene._s4_from6 = true;

        (s6.timers||[]).forEach(t=>{ try{ t.remove(false); }catch{} });
        s6.timers   = [];
        s6.locking  = false;
        s6.doneOnce = false;
      },

      leave(scene){
        const s6 = scene._s6; if (s6){
          (s6.timers||[]).forEach(t=>{ try{ t.remove(false); }catch{} });
          s6.timers = [];
          s6.locking = false;
        }
        scene._controlsLocked = false;
        scene._lockStopX = null;

        if (scene._s4_from6 && scene._s4) {
          try {
            if (scene._s4.bubble?.destroy)    scene._s4.bubble.destroy(true);
            if (scene._s4.npcBubble?.destroy) scene._s4.npcBubble.destroy(true);
          } catch(_) {}
          delete scene._s4_from6;
          delete scene._s4;
        }
      },

      update(scene, dt = 0.016){
        const s6 = scene._s6; if (!s6) return;

        if (s6.drone) {
          s6.drone_t += s6.drone_speed * dt;
          const a  = s6.drone_t;
          const x  = s6.drone_cx + s6.drone_rx * Math.cos(a);
          const y  = s6.drone_cy + s6.drone_ry * Math.sin(a) + 6 * Math.sin(a * 3);
          s6.drone.setPosition(x, y);

          const dx = -s6.drone_rx * Math.sin(a);
          s6.drone.setFlipX(dx < 0);
          s6.drone.rotation = 0.06 * Math.sin(a * 2);
        }

        const npcX = s6.npcWorldX();
        s6.npc.setFlipX(scene.player.x < npcX);

        if (!scene._s4 || scene._s4.npc !== s6.npc) {
          scene._s4 = { container: s6.container, npc: s6.npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };
          scene._s4_from6 = true;
        }

        if (s6.doneOnce) return;

        const dxP = Math.abs(scene.player.x - npcX);
        if (!s6.locking && dxP <= s6.triggerRadius) {
          s6.locking = true;
          scene._controlsLocked = true;
          scene._lockStopX = (scene.player.x < npcX) ? (npcX - s6.stopGap) : (npcX + s6.stopGap);

          const who = GameState.character || 'joaquin';
          scene.player.stop().setTexture(scene._idleKey || `${who}_idle`);
          scene.isMoving = false;

          s6.npc.play(s6.toastKey);

          const timers = [];
          timers.push(scene.time.delayedCall(300, () => {
            _s4ShowNpcBubble(scene, "Feliz aniversario, amor");
          }));
          timers.push(scene.time.delayedCall(1700, () => {
            _s4ShowBubble(scene, "Feliz aniversario");
          }));
          timers.push(scene.time.delayedCall(3500, () => {
            s6.doneOnce = true;
            s6.locking = false;
            scene._controlsLocked = false;
            scene._lockStopX = null;
          }));

          s6.timers = timers;
        }
      },
    },

    /* ------------ Scene 7 (Nala follower + dialog) ------------ */
    7: {
      manifest: {
        images: [
          { key:'scene7',       path:'/assets/scenes/scene7/scene7.png' },
          { key:'s7_sofia',     path:'/assets/sofia/casual/sofia_standing.png' },
          { key:'s7_joaquin',   path:'/assets/joaquin/casual/joaquin_standing.png' },
          { key:'s7_lokySit',   path:'/assets/loky/loky_sitting.png' },
          { key:'nala_walk1',   path:'/assets/nala/nala_walking1.png' },
          { key:'nala_walk2',   path:'/assets/nala/nala_walking2.png' },
          { key:'nala_walk3',   path:'/assets/nala/nala_walking3.png' },
          { key:'nala_stand',   path:'/assets/nala/nala_standing.png' },
        ]
      },

      build(scene, container){
        const baseImg = scene.textures.get('scene7').getSourceImage();
        const baseW   = baseImg.width;

        const NPC_REL_W        = 0.085;
        const NPC_IDLE_BOB_PX  = 3;
        const LOKY_REL_W       = 0.035;
        const LOKY_OFFSET_X    = 70;

        const TRIGGER_RADIUS   = 60;
        const STOP_GAP         = 22;

        const NALA_REL_W       = 0.090;
        const NALA_FOLLOW_GAP  = 26;
        const NALA_LERP        = 0.20;
        const NALA_APPROACH    = 120;
        const NALA_MOVE_EPS    = 0.02;

        const playableIsSofia = (GameState.character === 'sofia');
        const npcKey = playableIsSofia
          ? (scene.textures.exists('s7_joaquin') ? 's7_joaquin' : 's7_sofia')
          : 's7_sofia';

        const npcW  = scene.textures.get(npcKey).getSourceImage().width;
        const npc   = scene.add.sprite(0, 0, npcKey)
          .setOrigin(0.5, 1)
          .setScale((NPC_REL_W * baseW) / npcW)
          .setDepth(5);
        container.add(npc);

        scene.tweens.add({
          targets: npc,
          y: `-=${NPC_IDLE_BOB_PX}`,
          duration: 2200,
          yoyo: true,
          repeat: -1,
          ease: 'Sine.easeInOut'
        });

        const lokyW = scene.textures.get('s7_lokySit').getSourceImage().width;
        const loky  = scene.add.sprite(LOKY_OFFSET_X, 0, 's7_lokySit')
          .setOrigin(0.5, 1)
          .setScale((LOKY_REL_W * baseW) / lokyW)
          .setDepth(4);
        container.add(loky);

        const idleKey = scene.textures.exists('nala_stand') ? 'nala_stand' : 'nala_walk1';
        if (!scene.anims.exists('nala_walk_anim')) {
          const has = k => scene.textures.exists(k);
          const raw = [];
          if (has('nala_walk1')) raw.push({ key:'nala_walk1' });
          if (has('nala_walk2')) raw.push({ key:'nala_walk2' });
          if (has('nala_walk3')) raw.push({ key:'nala_walk3' });
          if (raw.length === 0) raw.push({ key: idleKey });
          if (raw.length === 1) raw.push(raw[0]);
          const frames = (raw.length >= 3) ? [raw[0], raw[1], raw[2], raw[1]] : raw;

          scene.anims.create({
            key: 'nala_walk_anim',
            frames,
            frameRate: 10,
            repeat: -1
          });
        }

        const nW = scene.textures.get(idleKey).getSourceImage().width;
        const nala = scene.add.sprite(-baseW * 0.35, 0, idleKey)
          .setOrigin(0.5, 1)
          .setScale((NALA_REL_W * baseW) / nW)
          .setDepth(4);
        container.add(nala);

        scene._s7 = {
          container, npc, loky,
          triggerRadius: TRIGGER_RADIUS,
          stopGap: STOP_GAP,
          dialogDone: false,
          timers: [],
          nala,
          nala_promoted: false,
          nala_idleKey: idleKey,
          nala_followGap: NALA_FOLLOW_GAP,
          nala_lerp: NALA_LERP,
          nala_approachSpeed: NALA_APPROACH,
          nala_moveEps: NALA_MOVE_EPS,
          nala_mode: 'idle',
          nala_leftBoundWorld: 0,
          nala_rightBoundWorld: 0,
        };
      },

      enter(scene){
        const s7 = scene._s7; if (!s7) return;

        const baseImg = scene.textures.get('scene7').getSourceImage();
        const sx = s7.container.scaleX || 1;
        const halfWorld = (baseImg.width * sx) * 0.5;
        s7.nala_leftBoundWorld  = s7.container.x - halfWorld;
        s7.nala_rightBoundWorld = s7.container.x + halfWorld;

        if (!s7.nala_promoted) {
          const sxC = s7.container.scaleX || 1;
          const worldX = s7.container.x + s7.nala.x * sxC;

          s7.container.remove(s7.nala);
          s7.nala.x = worldX;
          s7.nala.y = scene.railY;
          s7.nala.setScale(s7.nala.scaleX * sxC, s7.nala.scaleY * sxC);
          scene.add.existing(s7.nala);
          s7.nala_promoted = true;
        }

        s7.dialogDone = false;
        s7.nala.setTexture(s7.nala_idleKey);
        s7.nala_mode = 'idle';

        scene._s4 = { container: s7.container, npc: s7.npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };
      },

      leave(scene){
        const s7 = scene._s7;
        if (s7) {
          (s7.timers||[]).forEach(t => { try { t.remove(false); } catch(_){} });
          s7.timers = [];
          s7.nala.x = Phaser.Math.Clamp(s7.nala.x, s7.nala_leftBoundWorld, s7.nala_rightBoundWorld);
          if (s7.nala.anims?.isPlaying) s7.nala.stop();
          s7.nala.setTexture(s7.nala_idleKey);
        }
        scene._s7 = null;
      },

      update(scene, dt = 0.016){
        const s7 = scene._s7; if (!s7) return;

        const sx = s7.container.scaleX || 1;
        const npcWorldX = s7.container.x + (s7.npc.x * sx);
        const playerLeft = scene.player.x < npcWorldX;
        s7.npc.setFlipX(playerLeft);
        s7.loky.setFlipX(playerLeft);

        if (!scene._s4 || scene._s4.npc !== s7.npc) {
          scene._s4 = { container: s7.container, npc: s7.npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };
        }

        if (!s7.dialogDone && Math.abs(scene.player.x - npcWorldX) <= s7.triggerRadius) {
          s7.dialogDone = true;

          scene._controlsLocked = true;
          scene._lockStopX = (scene.player.x < npcWorldX)
            ? (npcWorldX - s7.stopGap)
            : (npcWorldX + s7.stopGap);

          const who = GameState.character || 'joaquin';
          scene.player.stop().setTexture(scene._idleKey || `${who}_idle`);
          scene.isMoving = false;

          _s4ShowNpcBubble(scene, "Ahora somos 4");

          const t1 = scene.time.delayedCall(2000, () => {
            _s4ShowNpcBubble(scene, "¡Bienvenida Nala!");
            _s4ShowBubble(scene, "¡Bienvenida Nala!");
          });

          const t2 = scene.time.delayedCall(4200, () => {
            scene._controlsLocked = false;
            scene._lockStopX = null;
          });

          s7.timers = [t1, t2];
        }

        const inside = (
          scene.player.x >= s7.nala_leftBoundWorld &&
          scene.player.x <= s7.nala_rightBoundWorld
        );

        if (!inside) {
          const atLeft = scene.player.x < s7.nala_leftBoundWorld;
          s7.nala.x = atLeft ? s7.nala_leftBoundWorld : s7.nala_rightBoundWorld;
          if (s7.nala.anims?.isPlaying) s7.nala.stop();
          s7.nala.setTexture(s7.nala_idleKey);
          s7.nala.setFlipX(scene.player.x < s7.nala.x);
          s7.nala_mode = 'idle';
          return;
        }

        if (s7.nala_mode === 'idle') s7.nala_mode = 'approachOnce';

        const gap      = s7.nala_followGap;
        const targetX  = scene.player.x + (scene.player.flipX ? -gap : gap);
        const desiredX = Phaser.Math.Clamp(targetX, s7.nala_leftBoundWorld, s7.nala_rightBoundWorld);

        s7.nala.setFlipX(desiredX < s7.nala.x);

        const prevX = s7.nala.x;
        let nextX   = prevX;

        if (s7.nala_mode === 'approachOnce') {
          const step  = s7.nala_approachSpeed * dt;
          const delta = Phaser.Math.Clamp(desiredX - prevX, -step, step);
          nextX = prevX + delta;
        } else {
          nextX = Phaser.Math.Linear(prevX, desiredX, s7.nala_lerp);
        }

        const moved = Math.abs(nextX - prevX) > (s7.nala_moveEps * 0.5);
        if (moved) {
          if (!s7.nala.anims?.isPlaying || s7.nala.anims.currentAnim?.key !== 'nala_walk_anim') {
            if (scene.anims.exists('nala_walk_anim')) s7.nala.play('nala_walk_anim', true);
          }
          if (scene.isMoving && scene.player.anims?.currentAnim && s7.nala.anims?.currentAnim) {
            const pf = scene.player.anims.currentFrame;
            const da = s7.nala.anims.currentAnim;
            if (pf && da && da.frames?.length > 0) {
              const idx = pf.index % da.frames.length;
              if (da.frames[idx]) s7.nala.anims.setCurrentFrame(da.frames[idx]);
            }
          }
        } else {
          if (s7.nala.anims?.isPlaying) s7.nala.stop();
          s7.nala.setTexture(s7.nala_idleKey);
        }

        s7.nala.x = nextX;

        if (s7.nala_mode === 'approachOnce' && Math.abs(desiredX - nextX) <= (s7.nala_moveEps * 3)) {
          s7.nala_mode = 'follow';
        }
      },
    },

    /* ------------ Scene 8 (proposal) ------------ */
8: {
  manifest: {
    images: [
      { key:'scene8',     path:'/assets/scenes/scene8/scene8.png' },
      { key:'s8_sofia',   path:'/assets/sofia/casual/sofia_standing.png' },
      { key:'s8_joaquin', path:'/assets/joaquin/casual/joaquin_standing.png' },
      { key:'s8_knee',    path:'/assets/joaquin/casual/joaquin_knee.png' },
      { key:'s8_ring',    path:'/assets/ring/ring17.png' }
    ]
  },

  build(scene, container){
    /* ===== CONFIGURABLE ===== */
    const SCALE = {
      SOFIA_REL_W:   0.065,   // standing Sofia width (vs bg width)
      JOAQUIN_REL_W: 0.065,   // standing Joaquin width
      KNEE_REL_W:    0.032,   // ↓ smaller kneel sprite (was 0.06)
      RING_REL_W:    0.040,   // ring size
      STOP_GAP:      17,
      TRIGGER_RADIUS:80,
      STEP_MS:       1500,
      TRANS_MS:      140,     // crossfade standing <-> kneel
      SETTLE_MS:     160      // small pause to ensure idle pose
    };
    const BOB_PX = 3;

    const baseW = scene.textures.get('scene8').getSourceImage().width;

    /* ===== WHO IS PLAYER / NPC ===== */
    const playerIsSofia = (GameState.character === 'sofia');
    const npcKey   = playerIsSofia ? 's8_joaquin' : 's8_sofia';
    const npcTexW  = scene.textures.get(npcKey).getSourceImage().width;
    const npcRelW  = playerIsSofia ? SCALE.JOAQUIN_REL_W : SCALE.SOFIA_REL_W;

    const npc = scene.add.sprite(0, 0, npcKey)
      .setOrigin(0.5, 1)
      .setScale((npcRelW * baseW) / npcTexW)
      .setDepth(900)
      .setAlpha(1);
    container.add(npc);

    scene.tweens.add({
      targets: npc,
      y: `-=${BOB_PX}`,
      duration: 2200,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });

    /* ===== PROPS (WORLD-SPACE) ===== */
    const kneeW = scene.textures.get('s8_knee').getSourceImage().width;
    const ringW = scene.textures.get('s8_ring').getSourceImage().width;

    const knee = scene.add.sprite(0, scene.railY, 's8_knee')
      .setOrigin(0.5,1)
      .setScale((SCALE.KNEE_REL_W * baseW) / kneeW)
      .setDepth(995)
      .setVisible(false)
      .setAlpha(0);

    const ring = scene.add.image(0, scene.railY, 's8_ring')
      .setOrigin(0.5,1)
      .setScale((SCALE.RING_REL_W * baseW) / ringW)
      .setDepth(960)
      .setVisible(false)
      .setAlpha(0);

    /* ===== STATE ===== */
    scene._s8 = {
      container, npc, knee, ring, SCALE,
      timers: [], playedOnce:false, sequenceRunning:false,

      killTimers(){ this.timers.forEach(t=>{try{t.remove(false);}catch{}}); this.timers=[]; },
      worldXOf(sprite){ const sx=this.container.scaleX||1; return this.container.x+(sprite.x*sx); },

      /* ---- Crossfade helpers (no “invisible” gap) ---- */
      _fadeIn(obj, ms=SCALE.TRANS_MS){ obj.setVisible(true); scene.tweens.add({targets:obj, alpha:1, duration:ms, ease:'Quad.easeOut'}); },
      _fadeOut(obj, ms=SCALE.TRANS_MS, hideAtEnd=true){
        scene.tweens.add({targets:obj, alpha:0, duration:ms, ease:'Quad.easeIn', onComplete:()=>{ if(hideAtEnd) obj.setVisible(false); }});
      },

      /* ---- Position & crossfade into kneel ---- */
      showKneeAndRing(){
        let kneelX, faceLeft, standTarget;
        if (playerIsSofia){
          kneelX   = this.worldXOf(this.npc);      // NPC (Joaquín) kneels
          faceLeft = (kneelX > scene.player.x);
          standTarget = this.npc;
        } else {
          kneelX   = scene.player.x;               // Player (Joaquín) kneels
          faceLeft = scene.player.flipX;
          standTarget = scene.player;
        }

        // place knee + ring
        this.knee.setPosition(kneelX, scene.railY).setFlipX(faceLeft);
        const kneeH = this.knee.displayHeight || 100;
        const offX  = faceLeft ? -28 : 28;
        const offY  = Math.max(36, Math.round(kneeH * 0.35));
        this.ring.setPosition(kneelX + offX, scene.railY - offY);

        // crossfade standing -> kneel (no blank gap)
        this._fadeIn(this.knee);
        this._fadeIn(this.ring, SCALE.TRANS_MS + 60);
        this._fadeOut(standTarget, SCALE.TRANS_MS, false); // keep it visible (alpha 0) for quick restore
      },

      /* ---- Crossfade back to standing smoothly ---- */
      standUpFromKnee(){
        // choose who stands back up
        const standTarget = playerIsSofia ? this.npc : scene.player;
        standTarget.setVisible(true);               // ensure present
        standTarget.setAlpha(0);                    // start transparent
        // fade knee/ring out while standing fades in
        this._fadeOut(this.knee, SCALE.TRANS_MS);
        this._fadeOut(this.ring, SCALE.TRANS_MS);
        this._fadeIn(standTarget, SCALE.TRANS_MS);
      },

      hideKneeAndRingImmediately(){
        this.knee.setVisible(false).setAlpha(0);
        this.ring.setVisible(false).setAlpha(0);
      },

      runSequence(){
        if (this.sequenceRunning || this.playedOnce) return;
        this.sequenceRunning = true;
        this.playedOnce      = true;

        // snap player to idle and stop near NPC
        const npcWorldX = this.worldXOf(this.npc);
        scene._controlsLocked = true;
        scene._lockStopX = (scene.player.x<npcWorldX) ? (npcWorldX - this.SCALE.STOP_GAP) : (npcWorldX + this.SCALE.STOP_GAP);
        const who = GameState.character || 'joaquin';
        scene.player.stop().setTexture(scene._idleKey || `${who}_idle`);
        scene.isMoving = false;

        // bubble proxy to NPC
        scene._s4 = { container:this.container, npc:this.npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };

        const add = (delay, fn) => this.timers.push(scene.time.delayedCall(delay, fn));
        let t = 0, STEP = this.SCALE.STEP_MS;

        // tiny settle so we never see mid-walk
        add(t += this.SCALE.SETTLE_MS, ()=>{});

        if (playerIsSofia){
          // NPC (Joaquín) proposes
          add(t += 0,    ()=> _s4ShowNpcBubble(scene, "Tengo que hacerte una pregunta"));
          add(t += STEP, ()=> this.showKneeAndRing());
          add(t += STEP, ()=> _s4ShowNpcBubble(scene, "¿Quieres casarte conmigo?"));
          add(t += STEP, ()=> _s4ShowBubble(scene, "¡Sí! 💍"));
          // stand up smoothly right after answer
          add(t += 50,   ()=> this.standUpFromKnee());
        } else {
          // Player (Joaquín) proposes
          add(t += 0,    ()=> _s4ShowNpcBubble(scene, "Qué lindo se ve acá"));
          add(t += STEP, ()=> _s4ShowBubble(scene, "Tengo que hacerte una pregunta"));
          add(t += STEP, ()=> this.showKneeAndRing());
          add(t += STEP, ()=> _s4ShowBubble(scene, "¿Quieres casarte conmigo?"));
          add(t += STEP, ()=> _s4ShowNpcBubble(scene, "¡Sí! 💍"));
          add(t += 50,   ()=> this.standUpFromKnee());
        }

        // wrap up
        add(t += STEP, ()=>{
          this.hideKneeAndRingImmediately();
          scene._controlsLocked = false;
          scene._lockStopX = null;
          this.sequenceRunning = false;
        });
      }
    };

    scene._s4 = { container, npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };
    scene._s4_from8 = true;
  },

  enter(scene){
    const s = scene._s8; if (!s) return;
    s.killTimers();
    s.sequenceRunning = false;
    s.hideKneeAndRingImmediately();
    scene._s4 = { container:s.container, npc:s.npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };
    scene._s4_from8 = true;
  },

  leave(scene){
    const s = scene._s8; if (!s) return;
    s.killTimers();
    s.hideKneeAndRingImmediately();
    scene._controlsLocked = false;
    scene._lockStopX = null;
    if (scene._s4_from8 && scene._s4){
      try{
        if (scene._s4.bubble?.destroy)    scene._s4.bubble.destroy(true);
        if (scene._s4.npcBubble?.destroy) scene._s4.npcBubble.destroy(true);
      }catch{}
      delete scene._s4_from8; delete scene._s4;
    }
    scene._s8 = null;
  },

  update(scene){
    const s = scene._s8; if (!s) return;
    const npcWorldX = s.worldXOf(s.npc);
    s.npc.setFlipX(scene.player.x < npcWorldX);

    // Proximity trigger (we force idle inside runSequence)
    if (!s.playedOnce && !s.sequenceRunning){
      const near = Math.abs(scene.player.x - npcWorldX) <= s.SCALE.TRIGGER_RADIUS;
      if (near) s.runSequence();
    }
  }
},
    /* ------------ Scene 9 (final strip / countdown) ------------ */
9: {
  // Flip to false if you want the countdown mode
  S9_FORCE_DONE: true,

  manifest: {
    images: [
      { key:'scene9',           path:'/assets/scenes/scene9/scene9.png' },
      { key:'s9_sofia_wedd',    path:'/assets/sofia/sofia_wedd.png' },
      { key:'s9_joaquin_wedd',  path:'/assets/joaquin/joaquin_wedd.png' },
    ]
  },

  _destroyCountdown(scene){
    const s = scene._c9; if (!s) return;
    if (s.timer){ try{s.timer.remove(false);}catch{} s.timer = null; }
    if (s.container?._c9_follow){ try{s.container._c9_follow.remove(false);}catch{} s.container._c9_follow = null; }
    if (s.ui){ try{s.ui.destroy(true);}catch{} s.ui = null; }
  },

  build(scene, container){
    /* ================= CONFIG ================= */
    const TARGET_ISO = '2026-03-07T12:00:00-03:00';
    const finishedByDate = (new Date() >= new Date(TARGET_ISO));
    const FINISHED = this.S9_FORCE_DONE || finishedByDate;

    // Wedding sprite scales (relative to bg width)
    const SCALE_NPC = {
      sofia:   0.105,
      joaquin: 0.105
    };

    // Countdown UI palette
    const SCALE_UI   = 1.0;
    const TITLE_TXT  = 'PRÓXIMAMENTE…';
    const COL_CARD      = 0x1a1f26;
    const COL_CARD_TOP  = 0x12161c;
    const COL_STROKE    = 0x00ffff;
    const COL_NUM       = '#ffffff';
    const COL_SHADOW    = '#003b3b';
    const COL_LABEL     = '#ffcc66';

    const bgSrc = scene.textures.get('scene9').getSourceImage();

    /* ================ STATE ================ */
    scene._c9 = {
      container,
      ui: null,
      timer: null,
      finished: FINISHED,
      target: new Date(TARGET_ISO),

      // Entities (finished mode)
      npcWedd: null,       // the standing wedding NPC (Sofía or Joaquín)
      npcKey: null,        // 's9_sofia_wedd' or 's9_joaquin_wedd'

      // Proximity/locks
      triggerRadius: 120,
      stopGap: 18,
      locking: false,
      doneOnce: false,
      dialogTimers: [],

      // Idle override management
      prevIdleKey: null,

      // Countdown blocks
      blocks: null,
    };

    const centerPos = ()=>{
      const sx = container.scaleX || 1, sy = container.scaleY || 1;
      const topY = container.y - (bgSrc.height * sy);
      return { x: container.x, y: topY + (bgSrc.height * sy) * 0.42 };
    };

    /* ============== MODE A: COUNTDOWN ============== */
    if (!FINISHED) {
      const p0 = centerPos();
      const ui = scene.add.container(0,0).setDepth(6000);
      scene._c9.ui = ui;

      const CARD_W = 780 * SCALE_UI, CARD_H = 210 * SCALE_UI;
      const cardShadow = scene.add.rectangle(p0.x+3, p0.y+5, CARD_W, CARD_H, 0x000000, 0.35).setOrigin(0.5);
      const card       = scene.add.rectangle(p0.x,   p0.y,   CARD_W, CARD_H, COL_CARD, 0.95)
                              .setOrigin(0.5).setStrokeStyle(6, COL_STROKE, 1);
      ui.add(cardShadow); ui.add(card);

      const topStrip = scene.add.rectangle(p0.x, p0.y - CARD_H/2 + 18*SCALE_UI, CARD_W-18*SCALE_UI, 28*SCALE_UI, COL_CARD_TOP, 1).setOrigin(0.5);
      ui.add(topStrip);

      const tY = topStrip.y;
      const titleShadow = scene.add.text(p0.x+1, tY+1, TITLE_TXT, { fontFamily:'monospace', fontSize:20*SCALE_UI, color:COL_SHADOW, letterSpacing:1 }).setOrigin(0.5);
      const title       = scene.add.text(p0.x,   tY,   TITLE_TXT, { fontFamily:'monospace', fontSize:20*SCALE_UI, color:'#a0f0ff', letterSpacing:1 }).setOrigin(0.5);
      ui.add(titleShadow); ui.add(title);

      const BOX_W = 150*SCALE_UI, BOX_H = 110*SCALE_UI, GAP = 20*SCALE_UI;
      const makeFlipBlock = (i, labelTxt, anchorX, baseY) => {
        const x = anchorX + i*(BOX_W+GAP), y = baseY;
        const shadow = scene.add.rectangle(x+3,y+4,BOX_W,BOX_H,0x000000,0.35).setOrigin(0.5);
        const box    = scene.add.rectangle(x,y,BOX_W,BOX_H,COL_CARD_TOP,1).setOrigin(0.5).setStrokeStyle(4,COL_STROKE,1);
        ui.add(shadow); ui.add(box);

        const mid = scene.add.line(0,0,x, y-BOX_H/2, x, y, 0x000000, 0.20).setLineWidth(2);
        ui.add(mid);

        const valShadow = scene.add.text(x+1, y-10+1, '00', { fontFamily:'monospace', fontSize:46*SCALE_UI, color:COL_SHADOW }).setOrigin(0.5);
        const val       = scene.add.text(x,   y-10,   '00', { fontFamily:'monospace', fontSize:46*SCALE_UI, color:COL_NUM    }).setOrigin(0.5);
        ui.add(valShadow); ui.add(val);

        const lab = scene.add.text(x, y + BOX_H/2 - 18*SCALE_UI, labelTxt, { fontFamily:'monospace', fontSize:14*SCALE_UI, color:COL_LABEL }).setOrigin(0.5);
        ui.add(lab);

        const flipTo = (txt)=>{
          if (val.text === txt) return;
          scene.tweens.add({
            targets:[val, valShadow],
            scaleY:0, duration:120, ease:'Quad.easeIn',
            onComplete:()=>{
              val.setText(txt); valShadow.setText(txt);
              scene.tweens.add({ targets:[val,valShadow], scaleY:1, duration:120, ease:'Quad.easeOut' });
            }
          });
        };

        return { val, valShadow, flipTo, box, shadow, lab };
      };

      const baseY = p0.y + 28*SCALE_UI;
      const startX = p0.x - (BOX_W*4 + GAP*3)/2 + BOX_W/2;

      const bDays = makeFlipBlock(0,'DÍAS',     startX, baseY);
      const bHrs  = makeFlipBlock(1,'HORAS',    startX, baseY);
      const bMin  = makeFlipBlock(2,'MINUTOS',  startX, baseY);
      const bSec  = makeFlipBlock(3,'SEGUNDOS', startX, baseY);

      container._c9_follow = scene.time.addEvent({
        delay:16, loop:true, callback:()=>{
          const p = centerPos();
          const ny = p.y + 28*SCALE_UI;
          const nx0 = p.x - (BOX_W*4 + GAP*3)/2 + BOX_W/2;
          card.setPosition(p.x,p.y); cardShadow.setPosition(p.x+3,p.y+5);
          topStrip.setPosition(p.x, p.y - CARD_H/2 + 18*SCALE_UI);
          [[bDays,0],[bHrs,1],[bMin,2],[bSec,3]].forEach(([b,i])=>{
            const x = nx0 + i*(BOX_W+GAP), y = ny;
            b.box.setPosition(x,y); b.shadow.setPosition(x+3,y+4);
            b.val.setPosition(x,y-10); b.valShadow.setPosition(x+1,y-9);
            b.lab.setPosition(x,y + BOX_H/2 - 18*SCALE_UI);
          });
          title.setPosition(p.x, topStrip.y);
          titleShadow.setPosition(title.x+1, title.y+1);
        }
      });

      scene._c9.blocks = { days:bDays, hrs:bHrs, min:bMin, sec:bSec };
      return;
    }

    /* ============== MODE B: FINISHED (WEDDING) ============== */

    // Decide NPC based on who the player is
    const playerIsSofia = (GameState.character === 'sofia');
    const npcKey = playerIsSofia ? 's9_joaquin_wedd' : 's9_sofia_wedd';
    scene._c9.npcKey = npcKey;

    const npcImg = scene.textures.get(npcKey).getSourceImage();
    const relW   = playerIsSofia ? SCALE_NPC.joaquin : SCALE_NPC.sofia;
    const scale  = (relW * bgSrc.width) / npcImg.width;

    const npcWedd = scene.add
      .sprite(0, 0, npcKey)
      .setOrigin(0.5, 1)
      .setScale(scale)
      .setDepth(6)
      .setFlipX(true);
    container.add(npcWedd);
    scene._c9.npcWedd = npcWedd;

    // Gentle bob
    scene.tweens.add({
      targets: npcWedd,
      y: '-=3',
      duration: 2200,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });
  },

  enter(scene){
    const s = scene._c9; if (!s) return;

    // COUNTDOWN mode
    if (!s.finished) {
      const pad2 = n => String(Math.floor(n)).padStart(2,'0');
      const target = s.target.getTime();
      const destroyCountdown = ()=> this._destroyCountdown(scene);

      const tick = ()=>{
        if (!scene._c9 || scene._c9.finished) return;
        const now  = Date.now();
        const diff = target - now;

        if (diff <= 0){
          destroyCountdown();
          s.finished = true; // next build/enter would be finished mode
          return;
        }
        const sec  = Math.floor(diff/1000);
        const days = Math.floor(sec / 86400);
        const hrs  = Math.floor((sec % 86400) / 3600);
        const mins = Math.floor((sec % 3600) / 60);
        const secs = sec % 60;

        s.blocks.days.flipTo(String(days).padStart(2,'0'));
        s.blocks.hrs .flipTo(pad2(hrs));
        s.blocks.min .flipTo(pad2(mins));
        s.blocks.sec .flipTo(pad2(secs));
      };

      tick();
      s.timer = scene.time.addEvent({ delay:1000, loop:true, callback:tick });
      return;
    }

    // FINISHED mode — set player idle override to their wedding outfit
    s.prevIdleKey = scene._idleKey;
    const playerIsSofia = (GameState.character === 'sofia');
    scene._idleKey = playerIsSofia ? 's9_sofia_wedd' : 's9_joaquin_wedd';
  },

  leave(scene){
    const s = scene._c9; if (!s) return;

    // Cleanup countdown
    this._destroyCountdown(scene);

    // Cleanup messages/locks
    (s.dialogTimers||[]).forEach(t=>{ try{ t.remove(false); }catch{} });
    s.dialogTimers = [];
    if (scene._s4?.bubble?.destroy)    try{ scene._s4.bubble.destroy(true); }catch{}
    if (scene._s4?.npcBubble?.destroy) try{ scene._s4.npcBubble.destroy(true); }catch{}
    scene._controlsLocked = false;
    scene._lockStopX = null;

    // Restore previous idle if we changed it
    if (s.prevIdleKey) {
      scene._idleKey = s.prevIdleKey;
      s.prevIdleKey = null;
    }

    scene._c9 = null;
  },

  update(scene){
    const s = scene._c9; if (!s) return;

    // If countdown is still active → nothing else here
    if (!s.finished) return;

    const sx = s.container.scaleX || 1;
    const npcWorldX = s.container.x + ((s.npcWedd?.x || 0) * sx);

    // NPC faces the player
    if (s.npcWedd) s.npcWedd.setFlipX(scene.player.x < npcWorldX);

    // Proximity trigger → lock, swap player to wedding outfit, dual “sí, acepto”, then FinalPhotoStrip
    if (!s.doneOnce && !s.locking) {
      const dx = Math.abs(scene.player.x - npcWorldX);
      if (dx <= s.triggerRadius) {
        s.locking = true;

        // Stop & lock player here
        scene._controlsLocked = true;
        scene._lockStopX = (scene.player.x < npcWorldX) ? (npcWorldX - s.stopGap) : (npcWorldX + s.stopGap);

        // Force the player into their wedding idle immediately (so outfit is visible first)
        const playerIsSofia = (GameState.character === 'sofia');
        const playerWeddingKey = playerIsSofia ? 's9_sofia_wedd' : 's9_joaquin_wedd';
        if (scene.textures.exists(playerWeddingKey)) {
          scene.player.stop().setTexture(playerWeddingKey);
        } else {
          scene.player.stop();
        }
        scene.player.setFlipX(scene.player.x > npcWorldX);
        scene.isMoving = false;

        // Bubbles target the NPC
        scene._s4 = { container: s.container, npc: s.npcWedd, ui:null, uiFollow:null, bubble:null, npcBubble:null };

        const timers = [];

        // NPC says "sí" first
        timers.push(scene.time.delayedCall(0, () => {
          _s4ShowNpcBubble(scene, "¡sí, acepto!");
        }));

        // Ensure player's outfit is wedding (already set, but keep it solid)
        timers.push(scene.time.delayedCall(200, () => {
          if (scene.textures.exists(playerWeddingKey)) {
            scene.player.setTexture(playerWeddingKey);
          }
        }));

        // Player replies
        timers.push(scene.time.delayedCall(400, () => {
          _s4ShowBubble(scene, "¡sí, acepto!");
        }));

        // Launch final overlay
        timers.push(scene.time.delayedCall(800, () => {
          scene.scene.launch('FinalPhotoStrip');
          scene.scene.bringToTop('FinalPhotoStrip');
        }));

        s.dialogTimers = timers;
        s.doneOnce = true; // one-shot
      }
    }
  },
}
  };

  /* ================================================
     CORE SCENES
  ================================================= */

  class StartMenu extends Phaser.Scene {
    constructor(){ super('StartMenu'); }
    create(){
      const { width, height } = this.scale;
      this.add.text(width/2, height*0.3, 'NUESTRAS MEMORIAS', { fontFamily:'monospace', fontSize:32, color:'#ffffff' }).setOrigin(0.5);
      const btn = this.add.text(width/2, height*0.55, '[ INCIAR ]', { fontFamily:'monospace', fontSize:24, color:'#00ffff', backgroundColor:'#111' }).setOrigin(0.5).setInteractive({ useHandCursor:true });
      btn.on('pointerup', ()=> this.scene.start('SoundSelect'));
    }
  }

  class SoundSelect extends Phaser.Scene {
    constructor(){ super('SoundSelect'); }
    preload(){ this.load.audio('bgm', ['/assets/audio/bgm.mp3']); }
    create(){
      const { width, height } = this.scale;
      this.add.text(width/2, height*0.3, 'SONIDO?', { fontFamily:'monospace', fontSize:28, color:'#ffffff' }).setOrigin(0.5);
      this._btn(width/2 - 80, height*0.55, '[ SI ]',  ()=> this._choose(true));
      this._btn(width/2 + 80, height*0.55, '[ NO ]', ()=> this._choose(false));
    }
    _btn(x,y,label,onClick){
      const t = this.add.text(x,y,label,{ fontFamily:'monospace', fontSize:22, color:'#00ffff', backgroundColor:'#111' }).setOrigin(0.5).setInteractive({ useHandCursor:true });
      t.on('pointerup', onClick);
      return t;
    }
    _choose(on){
      GameState.sound = on;

      if (!GameState.bgm) {
        GameState.bgm = this.sound.add('bgm', { loop:true, volume:0.12 });
      } else {
        this.sound.removeByKey('bgm');
        GameState.bgm = this.sound.add('bgm', { loop:true, volume:0.12 });
      }
      if (on) {
        if (!GameState.bgm.isPlaying) GameState.bgm.play();
      } else {
        if (GameState.bgm.isPlaying) GameState.bgm.pause();
      }

      this.scene.start('CharacterSelect');
    }
  }

class FinalPhotoStrip extends Phaser.Scene {
  constructor(){ super('FinalPhotoStrip'); }

  preload(){
    // Carga 6 fotos reales: /public/assets/real/foto_real1.jpg ... foto_real6.jpg
    for (let i=1; i<=6; i++){
      const key = `real${i}`;
      if (!this.textures.exists(key)) {
        this.load.image(key, `/assets/real/foto_real${i}.jpg`);
      }
    }
  }

  create(){
    const { width:W, height:H } = this.scale;

    // Apaga música/sonido de la escena anterior
    try {
      this.sound.stopAll();
      if (window.GameState?.bgm) { try { GameState.bgm.stop(); } catch(_) {} GameState.bgm = null; }
      if (this.sound.context && this.sound.context.state !== 'suspended') {
        this.sound.context.suspend().catch(()=>{});
      }
    } catch(_) {}

    // Dim de fondo
    const dim = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0.0).setDepth(20000).setScrollFactor(0);
    this.tweens.add({ targets: dim, alpha: 0.65, duration: 500, ease: 'Sine.easeOut' });

    /* =================== TUNABLES RÁPIDOS =================== */
    const PHOTO_WIDTH_FRACTION = 0.28;   // tamaño base de “polaroid” ~28% del ancho
    const OVERLAP_TIGHTNESS    = 0.75;   // 1 = sin solape; <1 = más solape (0.75 recomendado)
    const ROT_EXTRA            = 0.02;   // leve aleatoriedad de rotación
    const DROP_STAGGER         = 180;    // retardo entre caídas de cada foto
    /* ======================================================== */

    // Crea un “marco” tipo polaroid: borde blanco + imagen + (sin caption)
    const mkPolaroid = (texKey)=>{
      const pw = Math.min(320, W * PHOTO_WIDTH_FRACTION);
      const ph = Math.round(pw * 1.25);
      const border = 12;    // borde blanco total
      const bottomPad = 36; // “mentón” inferior del marco

      const frame = this.add.rectangle(0,0,pw,ph,0xffffff,1)
        .setStrokeStyle(3, 0xeeeeee, 1).setOrigin(0.5,0.5);

      const innerW = pw - border*2;
      const innerH = ph - border - bottomPad;

      const img = this.add.image(0, -((bottomPad - border)/2), texKey).setOrigin(0.5,0.5);
      const src = this.textures.get(texKey)?.getSourceImage();
      if (src) {
        img.setScale(Math.min(innerW/src.width, innerH/src.height));
      }

      const c = this.add.container(W/2, -ph, [frame, img]).setDepth(20001);
      c._pw = pw; c._ph = ph;
      c._shadow = this.add.rectangle(W/2+6, -ph+8, pw, ph, 0x000000, 0.22)
        .setDepth(20000).setOrigin(0.5,0.5);

      return c;
    };

    // Reúne las 6 fotos reales (si alguna no cargó, la omite)
    const keys = [];
    for (let i=1; i<=6; i++){
      const k = `real${i}`;
      if (this.textures.exists(k)) keys.push(k);
    }

    // Crea polaroids para cada foto
    const photos = keys.map(k => mkPolaroid(k));

    // Disposición tipo collage con solape (todas visibles)
    // Centro visual
    const cx = W * 0.5;
    const cy = H * 0.55;

    // Separación base entre centros (se reduce con OVERLAP_TIGHTNESS)
    const pw = photos[0]? photos[0]._pw : Math.min(320, W*PHOTO_WIDTH_FRACTION);
    const ph = photos[0]? photos[0]._ph : Math.round(pw*1.25);
    const dx = pw * 0.85 * OVERLAP_TIGHTNESS;
    const dy = ph * 0.55 * OVERLAP_TIGHTNESS;

    // Targets manuales con leve variación. Ajusta posiciones si deseas
    const targets = [
      { x: cx - dx*1.2, y: cy - dy*0.9, rot: -0.10 },
      { x: cx - dx*0.2, y: cy - dy*1.1, rot:  0.06 },
      { x: cx + dx*0.9, y: cy - dy*0.8, rot: -0.03 },
      { x: cx - dx*0.9, y: cy + dy*0.2, rot:  0.03 },
      { x: cx + dx*0.2, y: cy + dy*0.5, rot: -0.07 },
      { x: cx + dx*1.2, y: cy + dy*0.1, rot:  0.09 },
    ].slice(0, photos.length);

    // Anima cada foto con caída “Back.Out” y solapamiento suave
    photos.forEach((p, i)=>{
      const t = targets[i];
      const delay = 240 + i*DROP_STAGGER;
      const baseRot = t.rot + ((Math.random()*2-1)*ROT_EXTRA);

      p.setRotation((baseRot>0?baseRot-0.30:baseRot+0.30));

      // sombra
      this.tweens.add({
        targets: p._shadow,
        delay, duration: 650, ease: 'Back.Out',
        x: t.x + 6, y: t.y + 8
      });

      // polaroid
      this.tweens.add({
        targets: p,
        delay, duration: 650, ease: 'Back.Out',
        x: t.x, y: t.y, rotation: baseRot
      });

      // orden de profundidad para que queden “encima” de forma agradable
      p.setDepth(20001 + i);
      p._shadow.setDepth(20000 + i);
    });

    // Sello de texto
    const STAMP_TEXT = 'Felices por siempre';
    const stampDepth = 30002;
    const stampY     = H * 0.12;
    const fontSize   = Math.min(58, W*0.075);

    const stamp = this.add.text(W/2, stampY, STAMP_TEXT, {
      fontFamily: 'monospace',
      fontSize: fontSize,
      color: '#ffffff',
      align: 'center',
      letterSpacing: 1
    })
    .setOrigin(0.5)
    .setDepth(stampDepth)
    .setAlpha(0)
    .setScale(1.35)
    .setRotation(-0.06)
    .setStroke('#000000', Math.max(4, Math.round(fontSize * 0.12)))
    .setShadow(0, Math.max(2, Math.round(fontSize * 0.05)), '#000000', Math.max(6, Math.round(fontSize * 0.1)), true, true);

    const stampDrop = this.add.text(W/2 + 3, stampY + 3, STAMP_TEXT, {
      fontFamily: 'monospace',
      fontSize: fontSize,
      color: '#000000',
      align: 'center',
      letterSpacing: 1
    })
    .setOrigin(0.5)
    .setDepth(stampDepth - 1)
    .setAlpha(0)
    .setScale(1.35)
    .setRotation(-0.06);

    const sub = this.add.text(W/2, stampY + Math.min(64, H*0.065), '¡Que vivan los novios!', {
      fontFamily:'monospace',
      fontSize: Math.min(22, W*0.03),
      color:'#ffffff'
    })
    .setOrigin(0.5)
    .setDepth(stampDepth)
    .setAlpha(0)
    .setStroke('#000000', 3)
    .setShadow(0, 2, '#000000', 6, true, true);

    const afterDrop = 240 + photos.length*DROP_STAGGER + 260;

    this.time.delayedCall(afterDrop, ()=>{
      stamp.setAlpha(1);
      stampDrop.setAlpha(0.45);
      this.tweens.add({ targets: [stamp, stampDrop], duration: 280, ease: 'Back.Out', scale: 1.0, rotation: -0.02 });
    });

    this.tweens.add({ targets: sub, delay: afterDrop + 320, duration: 620, alpha: 1, ease: 'Sine.easeOut' });

    // Vignette suave
    const vignette = this.add.graphics().setDepth(20003);
    this.tweens.add({
      targets: vignette, delay: 300, duration: 1000,
      onUpdate: (_, t)=>{
        vignette.clear();
        vignette.fillStyle(0x000000, 0.20*Math.min(1,t));
        vignette.fillRect(0,0,W,H);
      }
    });

    // Zoom sutil final
    this.cameras.main.setZoom(1);
    this.tweens.add({ targets: this.cameras.main, zoom: 1.04, duration: 1600, delay: afterDrop, ease: 'Sine.easeInOut' });

    // Salida a StartMenu
    const total = afterDrop + 2200;
    this.time.delayedCall(total, ()=>{
      this.cameras.main.fadeOut(900, 0,0,0);
      this.cameras.main.once(Phaser.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, ()=>{
        const play = this.scene.get('Play');
        if (play) { play.scene.stop(); }
        this.scene.stop();
        this.scene.start('StartMenu');
      });
    });

    // Responsivo: recoloca sello y subtítulo
    this.scale.on('resize', (size)=>{
      dim.setSize(size.width, size.height).setPosition(size.width/2, size.height/2);
      const ny = size.height * 0.12;
      stamp.setPosition(size.width/2, ny);
      stampDrop.setPosition(size.width/2 + 3, ny + 3);
      sub.setPosition(size.width/2, ny + Math.min(64, size.height*0.065));
    });

    
  }
}

  class CharacterSelect extends Phaser.Scene {
    constructor(){ super('CharacterSelect'); }
    preload(){
      this.load.image('joaquin_idle', '/assets/joaquin/scene1/joaquin_standing.png');
      for (let i=1;i<=6;i++) this.load.image(`joaquin_walk${i}`, `/assets/joaquin/scene1/joaquin_walk${i}.png`);
      this.load.image('sofia_idle', '/assets/sofia/scene1/sofia_standing.png');
      for (let i=1;i<=6;i++) this.load.image(`sofia_walk${i}`, `/assets/sofia/scene1/sofia_walk${i}.png`);
    }
    create(){
      const { width, height } = this.scale;
      this.add.text(width/2, height*0.2, 'ESCOGE UN NOVIO', { fontFamily:'monospace', fontSize:24, color:'#ffffff' }).setOrigin(0.5);

      const joaquin = this.add.image(width/2 - 120, height*0.70, 'joaquin_idle')
        .setOrigin(0.5,1).setScale(0.6).setInteractive({ useHandCursor:true });
      const joaquinLabel = this.add.text(joaquin.x, joaquin.y+12, 'JOAQUÍN',
        { fontFamily:'monospace', fontSize:18, color:'#00ffff' }).setOrigin(0.5,0).setInteractive({ useHandCursor:true });

      const sofia = this.add.image(width/2 + 120, height*0.70, 'sofia_idle')
        .setOrigin(0.5,1).setScale(0.6).setInteractive({ useHandCursor:true });
      const sofiaLabel = this.add.text(sofia.x, sofia.y+12, 'SOFÍA',
        { fontFamily:'monospace', fontSize:18, color:'#ff7acb' }).setOrigin(0.5,0).setInteractive({ useHandCursor:true });

      const pick = (who) => { GameState.character = who; this.scene.start('Play'); };

      joaquin.on('pointerup', () => pick('joaquin'));
      joaquinLabel.on('pointerup', () => pick('joaquin'));
      sofia.on('pointerup', () => pick('sofia'));
      sofiaLabel.on('pointerup', () => pick('sofia'));

      this.input.keyboard.on('keydown-J', () => pick('joaquin'));
      this.input.keyboard.on('keydown-S', () => pick('sofia'));
      this.input.keyboard.on('keydown-ENTER', () => pick('joaquin')); // default
    }
  }

  /* ------- Mobile controls helper ------- */
  class MobileInput {
    constructor(){
      this.dir = 0; // -1 left, 1 right
      const leftBtn  = document.getElementById('btnLeft');
      const rightBtn = document.getElementById('btnRight');
      const mc = document.getElementById('mobileControls');

      const press = (btn, v)=>{ btn.classList.add('mc-pressed'); this.dir = v; };
      const release = (btn)=>{ btn.classList.remove('mc-pressed'); this.dir = 0; };

      const bind = (btn, v)=>{
        const onDown = (e)=>{ e.preventDefault(); press(btn, v); };
        const onUp   = (e)=>{ e.preventDefault(); release(btn); };

        btn.addEventListener('pointerdown', onDown, { passive:false });
        btn.addEventListener('pointerup',   onUp,   { passive:false });
        btn.addEventListener('pointercancel', onUp, { passive:false });
        btn.addEventListener('pointerleave',  onUp, { passive:false });
      };
      bind(leftBtn, -1);
      bind(rightBtn, 1);

      // Hide on large screens
      const mq = window.matchMedia('(min-width: 900px)');
      const update = ()=>{ mc.style.display = mq.matches ? 'none' : 'grid'; };
      mq.addEventListener?.('change', update);
      update();
    }
  }
  const MOBILE_INPUT = new MobileInput();

  class Play extends Phaser.Scene {
    constructor(){ super('Play'); }
    preload(){
      const who   = GameState.character || 'joaquin';
      const other = (who === 'sofia') ? 'joaquin' : 'sofia';

      if (!this.textures.exists(`${who}_idle`)) {
        this.load.image(`${who}_idle`, `/assets/${who}/scene1/${who}_standing.png`);
        for (let i=1;i<=6;i++) this.load.image(`${who}_walk${i}`, `/assets/${who}/scene1/${who}_walk${i}.png`);
      }
      if (!this.textures.exists(`${other}_idle`)) {
        this.load.image(`${other}_idle`, `/assets/${other}/scene1/${other}_standing.png`);
        for (let i=1;i<=6;i++) this.load.image(`${other}_walk${i}`, `/assets/${other}/scene1/${other}_walk${i}.png`);
      }

      if (!this.textures.exists('joaquin_wedd')) {
        this.load.image('joaquin_wedd', '/assets/joaquin/joaquin_wedd.png');
      }

      const whoDir = `/assets/${who}/casual/`;
      if (!this.textures.exists(`${who}_idle_casual`)) {
        this.load.image(`${who}_idle_casual`, `${whoDir}${who}_standing.png`);
        for (let i=1;i<=6;i++) this.load.image(`${who}_walk_casual_${i}`, `${whoDir}${who}_walk${i}.png`);
      }

      this.load.audio('s1_birds',    ['/assets/audio/birds.mp3']);
      this.load.audio('s1_ambience', ['/assets/audio/ambience.mp3']);
      if (!this.cache.audio.exists('bgm')) this.load.audio('bgm', ['/assets/audio/bgm.mp3']);
      if (!this.cache.audio.exists('scene4_song')) this.load.audio('scene4_song', ['/assets/audio/greenday.mp3']);
    }

    create(){
      /* --- responsive metrics (update also on resize) --- */
      const setMetrics = ()=>{
        this.h = this.scale.height;
        this.railY = Math.round(this.h * 0.80);                 // ground line
        this.TARGET_H = Math.max(280, Math.min(420, this.h*0.47)); // background target height
        this.SPACING = Math.max(900, Math.min(1400, this.scale.width * 1.10));
      };
      setMetrics();

      this.COUNT = 9;
      this.START_X = Math.max(480, Math.min(900, this.scale.width * 0.6));
      this.worldWidth = this.START_X + (this.COUNT - 1)*this.SPACING + 600;

      this.cameras.main.setBounds(0, 0, this.worldWidth, this.h);

      this.gfx = this.add.graphics().setDepth(-10);
      this._drawGround();

      const who = GameState.character || 'joaquin';
      this._ensureWalkAnim(who);

      this.player = this.add.sprite(150, this.railY, `${who}_idle`).setOrigin(0.5,1).setScale(0.2).setDepth(1000);

      this._walkKey = `${who}_walk`;
      this._idleKey = `${who}_idle`;

      this.cameras.main.startFollow(this.player, true, 0.15, 0.15);

      this.cursors = this.input.keyboard.createCursorKeys();
      this.keyA = this.input.keyboard.addKey('A');
      this.keyD = this.input.keyboard.addKey('D');
      this.speed = 200;
      this.isMoving = false;

      this.input.once('pointerdown', () => {
        if (this.sound.locked) this.sound.unlock();
        if (this.sound.context && this.sound.context.state === 'suspended') {
          this.sound.context.resume().catch(()=>{});
        }
      });

      this.thoughtBubble = this.add.text(
        this.player.x, this.player.y - this.player.displayHeight - 40,
        "Aquí empezó todo...",
        { fontFamily:"monospace", fontSize:14, color:"#ffffff", backgroundColor:"#000000" }
      ).setOrigin(0.5,1).setDepth(3000).setAlpha(0);
      this._bubbleVisible = false;

      this.zone = { current: null, containers: Array(this.COUNT).fill(null), loaded: new Set() };
      this._ensureZone(1);
      this._ensureNeighbors(1);

     // BELOW the feet, just past the rail/ground line
const helpText = (this.scale.width < 900 ? 'Use  ◀ ▶ para caminar' : 'Use \u2190 / \u2192 para caminar');
this.help = this.add.text(
  this.player.x,
  this.railY + 8,                  // <— under the ground line
  helpText,
  { fontFamily:'monospace', fontSize:14, color:'#ffffff' }
)
.setOrigin(0.5, 0)                 // <— anchor from TOP (grows downward)
.setDepth(2000);


      this._outfitBoundaryX = this._zoneBounds(3).right;
      this._lastX = this.player.x;

      if (this.player.x >= this._outfitBoundaryX) this._applyOutfit('casual'); else this._applyOutfit('primary');

      if (!GameState.bgm) {
        GameState.bgm = this.sound.add('bgm', { loop:true, volume:0.1 });
      }
      this.bgm = GameState.bgm;

      this.ambBirds = this.sound.add('s1_birds',    { loop:true, volume:0.1 });
      this.ambAtmo  = this.sound.add('s1_ambience', { loop:true, volume:0.3 });

      const UI_RIGHT_GUTTER = 80;
      this.soundIcon = this.add.text(this.scale.width - UI_RIGHT_GUTTER, 16,
        (GameState.sound && this.bgm.isPlaying ? '🔊' : '🔇'),
        { fontFamily:'monospace', fontSize:24, color:'#ffffff' })
        .setOrigin(1,0)
        .setScrollFactor(0)
        .setDepth(5000)
        .setInteractive({ useHandCursor:true });

      this.soundIcon.on('pointerup', () => {
        const turnOn = !(GameState.sound && (
          (this.bgm && (this.bgm.isPlaying || this.bgm.isPaused)) ||
          (this._s4 && this._s4.song && (this._s4.song.isPlaying || this._s4.song.isPaused))
        ));
        GameState.sound = turnOn;

        if (turnOn) {
          if (this.zone.current !== 4 || !(this._s4 && this._s4.songPlaying)) {
            if (this.bgm && !this.bgm.isPlaying) this.bgm.isPaused ? this.bgm.resume() : this.bgm.play();
          }
          if (this.zone.current === 1) {
            if (this.ambBirds && !this.ambBirds.isPlaying) this.ambBirds.play();
            if (this.ambAtmo  && !this.ambAtmo.isPlaying)  this.ambAtmo.play();
          }
          if (this.zone.current === 4 && this._s4 && this._s4.song && this._s4.song.isPaused) {
            this._s4.song.resume();
          }
          this.soundIcon.setText('🔊');
        } else {
          if (this.bgm && this.bgm.isPlaying) this.bgm.pause();
          if (this.ambBirds && this.ambBirds.isPlaying) this.ambBirds.pause();
          if (this.ambAtmo  && this.ambAtmo.isPlaying)  this.ambAtmo.pause();
          if (this._s4 && this._s4.song && this._s4.song.isPlaying) this._s4.song.pause();
          this.soundIcon.setText('🔇');
        }
      });

      this.scale.on('resize', (size) => {
        setMetrics();
        this.cameras.main.setBounds(0, 0, this.worldWidth, size.height);
        this._drawGround();
        this.soundIcon.setPosition(size.width - UI_RIGHT_GUTTER, 16);

        // Re-scale loaded zones to new TARGET_H
        for (let i=1;i<=this.COUNT;i++){
          const c = this.zone.containers[i-1];
          if (!c) continue;
          const baseKey =
            (ZONE_DEFS[i]?.manifest?.images?.find(img=>img.key.startsWith('scene'))?.key) ||
            `scene${i}`;
          const src = this.textures.get(baseKey).getSourceImage();
          const scale = this.TARGET_H / src.height;
          c.setScale(scale);
        }
      });
    }

    update(_, dtMS){
      const dt = dtMS / 1000;

      // Keyboard + Mobile virtual pad
      const left  = this.cursors.left.isDown || this.keyA.isDown || (MOBILE_INPUT.dir < 0);
      const right = this.cursors.right.isDown || this.keyD.isDown || (MOBILE_INPUT.dir > 0);
      let dir = right && !left ? 1 : left && !right ? -1 : 0;

      if (this._controlsLocked) dir = 0;

      const who = GameState.character || 'joaquin';
      if (dir !== 0) {
        const nx = Phaser.Math.Clamp(this.player.x + dir * this.speed * dt, 0, this.worldWidth);
        this.player.setX(nx).setFlipX(dir < 0);
        const walkKey = this._walkKey || `${who}_walk`;
        if (!this.isMoving || this.player.anims.currentAnim?.key !== walkKey) {
          this.player.play(walkKey, true);
          this.isMoving = true;
        }
      } else if (this.isMoving) {
        this.player.stop().setTexture(this._idleKey || `${who}_idle`);
        this.isMoving = false;
      }

      if (this._lockStopX != null) {
        if (this.player.x < this._lockStopX && !this.player.flipX) {
          this.player.x = Math.min(this.player.x, this._lockStopX);
        } else if (this.player.x > this._lockStopX && this.player.flipX) {
          this.player.x = Math.max(this.player.x, this._lockStopX);
        }
      }

      const b = this._outfitBoundaryX;
      const prevX = this._lastX;
      const curX  = this.player.x;

      if (prevX < b && curX >= b) this._applyOutfit('casual');
      else if (prevX >= b && curX < b) this._applyOutfit('primary');
      this._lastX = curX;

      let idx = Math.floor(
        (this.player.x - (this.START_X - this.SPACING / 2)) / this.SPACING
      ) + 1;

      idx = Phaser.Math.Clamp(idx, 1, this.COUNT);
      if (idx !== this.zone.current) this._switchZone(idx);

      const def = ZONE_DEFS[this.zone.current];
      if (def?.update) def.update(this, dt);

      this._ensureNeighbors(this.zone.current || 1);

      this.thoughtBubble.setPosition(this.player.x, this.player.y - this.player.displayHeight - 40);
     // Keep help pinned under the player’s feet, but never off-screen
const cam = this.cameras.main;
const padBottom = 12;           // margin from bottom of the screen
const desiredY  = this.railY + 8;
const maxY      = cam.worldView.bottom - padBottom;

this.help.setPosition(
  this.player.x,
  Math.min(desiredY, maxY)      // clamp so it doesn't get cut off
);


      if (this._enforceScale) this._enforceScale();
    }

    _drawGround(){
      this.gfx.clear();
      this.gfx.lineStyle(2, 0x00ffff, 1);
      this.gfx.moveTo(0, this.railY);
      this.gfx.lineTo(this.worldWidth, this.railY);
      this.gfx.strokePath();
    }
    _ensureWalkAnim(who){
      const key = `${who}_walk`;
      const framesAvailable = [1,2,3,4,5,6].every(i => this.textures.exists(`${who}_walk${i}`));
      if (framesAvailable && !this.anims.exists(key)) {
        this.anims.create({
          key,
          frames: [1,2,3,4,5,6].map(i => ({ key: `${who}_walk${i}` })),
          frameRate: 12,
          repeat: -1
        });
      }
    }

    _zoneBounds(index){
      const center = this.START_X + (index - 1) * this.SPACING;
      const half   = this.SPACING * 0.5;
      return { left:center - half, right:center + half, center };
    }

    _switchZone(index){
      const prev = this.zone.current;
      if (prev){
        const defPrev = ZONE_DEFS[prev];
        if (defPrev?.leave) defPrev.leave(this);
      }
      this.zone.current = index;
      const defNew = ZONE_DEFS[index];
      if (defNew?.enter) defNew.enter(this);
    }

    _ensureZone(index){
      if (!index || index < 1 || index > this.COUNT) return;
      if (this.zone.loaded.has(index)) return;

      const def = ZONE_DEFS[index] || null;

      let needLoad = false;
      (def?.manifest?.images || []).forEach(img => {
        if (!this.textures.exists(img.key)) { this.load.image(img.key, img.path); needLoad = true; }
      });

      if (!def?.manifest?.images && !this.textures.exists(`scene${index}`)) {
        this.load.image(`scene${index}`, `/assets/scenes/scene${index}/scene${index}.png`);
        needLoad = true;
      }

      if (needLoad) {
        this.load.once(Phaser.Loader.Events.COMPLETE, () => { this._buildZone(index, def); });
        this.load.start();
      } else {
        this._buildZone(index, def);
      }
    }

    _addStaticSceneTitle(container, baseKey, index){
      const src = this.textures.get(baseKey).getSourceImage();
      const label = (ZONE_TITLES[index] || `scene ${index}`).toUpperCase();

      const localX = 0;
      const localY = -src.height + 40;

      const baseFontSize = 60;
      const strokeW = 10;

      const t = this.add.text(localX, localY, label, {
        fontFamily: 'monospace',
        fontSize: baseFontSize,
        color: '#ffffff',
        align: 'center',
        letterSpacing: 1
      })
      .setOrigin(0.5, 0)
      .setDepth(10)
      .setStroke('#000000', strokeW)
      .setShadow(
        0,
        Math.max(2, Math.round(strokeW * 0.6)),
        '#000000',
        Math.max(6, Math.round(strokeW * 1.6)),
        true,
        true
      );

      container.add(t);
    }

    _buildZone(index, def){
      const old = this.zone.containers[index-1];
      if (old) old.destroy(true);

      const { center } = this._zoneBounds(index);
      const baseKey =
        (def?.manifest?.images?.find(i=>i.key.startsWith('scene'))?.key) ||
        `scene${index}`;

      const base = this.add.image(0,0, baseKey).setOrigin(0.5,1).setDepth(0);
      const container = this.add.container(center, this.railY, [base]).setDepth(0);

      const src = this.textures.get(baseKey).getSourceImage();
      const scale = this.TARGET_H / src.height;
      container.setScale(scale);

      const bgColor = ZONE_BG_COLORS[(index - 1) % ZONE_BG_COLORS.length];
      const bg = this.add.rectangle(0, 0, src.width, src.height + 120, bgColor, 1)
        .setOrigin(0.5, 1)
        .setAlpha(ZONE_BG_ALPHA);
      container.addAt(bg, 0);

      if (SHOW_ZONE_EDGES) {
        const edgeH = src.height + 140;
        const edgeW = 6;
        const leftEdge  = this.add.rectangle(-src.width / 2, 0, edgeW, edgeH, 0xffffff, 0.28).setOrigin(0.5, 1);
        const rightEdge = this.add.rectangle( src.width / 2, 0, edgeW, edgeH, 0xffffff, 0.28).setOrigin(0.5, 1);
        container.addAt(rightEdge, 2);
        container.addAt(leftEdge, 1);
      }

      const defObj = ZONE_DEFS[index];
      if (defObj?.build) defObj.build.call(defObj, this, container);

      this.zone.containers[index-1] = container;
      this.zone.loaded.add(index);

      this._addStaticSceneTitle(container, baseKey, index);
    }

    _destroyZone(index){
      if (!this.zone.loaded.has(index)) return;
      const def = ZONE_DEFS[index];

      if (def?.leave) def.leave(this);

      const c = this.zone.containers[index-1];
      if (c){ c.destroy(true); this.zone.containers[index-1] = null; }

      (def?.manifest?.images || []).forEach((img) => {
        if (img.key.startsWith('scene') && this.textures.exists(img.key)) {
          this.textures.remove(img.key);
        }
      });

      this.zone.loaded.delete(index);
      if (index === 2 && this._npc2) { this._npc2.destroy(true); this._npc2 = null; }
      if (index === 1 && this._npc)  { this._npc.destroy(true);  this._npc  = null; }
    }

    _ensureNeighbors(index){
      const keep = new Set([1, index-1, index, index+1].filter(i=> i>=1 && i<=this.COUNT));
      keep.forEach(i => this._ensureZone(i));
      for (let i=1;i<=this.COUNT;i++){
        if (!keep.has(i) && this.zone.loaded.has(i)) this._destroyZone(i);
      }
    }

    _buildCasualWalkAnimIfNeeded(){
      const who = GameState.character || 'joaquin';
      const animKey = `${who}_walk_casual`;
      if (this.anims.exists(animKey)) return animKey;
      const frames = [1,2,3,4,5,6].map(i => ({ key: `${who}_walk_casual_${i}` }));
      this.anims.create({ key: animKey, frames, frameRate: 12, repeat: -1 });
      return animKey;
    }

    _applyOutfit(mode){
      if (this._currentOutfit === mode) return;
      const who = GameState.character || 'joaquin';

      if (mode === 'casual') {
        const animKey = this._buildCasualWalkAnimIfNeeded();
        this._walkKey = animKey;
        this._idleKey = `${who}_idle_casual`;
      } else {
        this._ensureWalkAnim(who);
        this._walkKey = `${who}_walk`;
        this._idleKey = `${who}_idle`;
      }

      const scaleMap = {
        joaquin: { primary: 0.20, casual: 0.20 },
        sofia:   { primary: 0.18, casual: 0.05 },
      };
      const target = (scaleMap[who]?.[mode]) ?? 0.20;

      this.player.setScale(target);
      this._currentOutfit = mode;

      this._enforceScale = () => {
        if (Math.abs(this.player.scaleX - target) > 0.0001) {
          this.player.setScale(target);
        }
      };

      if (this.isMoving) this.player.play(this._walkKey, true);
      else this.player.stop().setTexture(this._idleKey);
    }
  }

  const game = new Phaser.Game({
    type: Phaser.AUTO,
    parent: document.getElementById('game-root'),
    width: window.innerWidth,
    height: window.innerHeight,
    backgroundColor:'#000',
    scene: [StartMenu, SoundSelect, CharacterSelect, Play, FinalPhotoStrip],
    scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH },
    render: { pixelArt:true, antialias:false, roundPixels:true },
    resolution: DPR
  });

  </script>
</body>
</html>
