<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Memory Walk (Game)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; width:100%; height:100%; background:#000; overflow:hidden; }
    #game-root { position:fixed; inset:0; width:100vw; height:100vh; }
    #game-root canvas {
      display:block;
      width:100% !important;
      height:100% !important;
      image-rendering:pixelated;
    }
  </style>
</head>
<body>
  <div id="game-root"></div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>

  <script>
  const GameState = { sound: true, character: null, bgm: null };

const ZONE_TITLES = {
  1: 'Un Comienzo',
  2: 'Entre Tonadas',
  3: 'El Paseo Diario',
  4: 'Mi Cancion Favorita',
  5: 'Nuestro Pequeño Locky',
  6: 'Aniversario En Pandemia',
  7: 'Entonces Fuimos Cuatro',
  8: 'Bajando Estrellas',
  9: 'El Dia Esperado',
};

  
  /* ===================== DEBUG ZONE BACKGROUNDS ===================== */
  const ZONE_BG_COLORS  = [0x263238, 0x3E2723, 0x1B5E20, 0x4A148C];
  const ZONE_BG_ALPHA   = 0.18;
  const SHOW_ZONE_EDGES = true;
  /* ================================================================== */

  /* ---------------- Scene 4 helpers + WORLD COORD HELPER ---------------- */
  function _worldPos(scene, container, obj) {
    const sx = container.scaleX ?? 1;
    const sy = container.scaleY ?? 1;
    return {
      x: container.x + (obj.x * sx),
      y: container.y + (obj.y * sy),
      w: (obj.displayWidth ?? obj.width ?? 0) * sx,
      h: (obj.displayHeight ?? obj.height ?? 0) * sy,
    };
  }

  function _s4ShowBubble(scene, text, opts = {}){
  const { autoHideMs = 1800 } = opts;
  const s4 = scene._s4; if (!s4) return;

  // limpia anterior si existe
  if (s4.bubble) {
    if (s4.bubble._follow) s4.bubble._follow.remove(false);
    s4.bubble.destroy(true);
  }

  const bubble = scene.add.text(
    scene.player.x,
    scene.player.y - scene.player.displayHeight - 40,
    text,
    { fontFamily:"monospace", fontSize:14, color:"#ffffff", backgroundColor:"#000000", align:"center" }
  ).setOrigin(0.5,1).setDepth(4000).setAlpha(0);
  s4.bubble = bubble;

  // fade-in
  scene.tweens.add({ targets:bubble, alpha:1, duration:300, ease:'Sine.easeInOut' });

  // seguir al player
  bubble._follow = scene.time.addEvent({
    delay:16, loop:true, callback:()=>{
      bubble.setPosition(scene.player.x, scene.player.y - scene.player.displayHeight - 40);
    }
  });

  // auto-ocultar si se pide
  if (autoHideMs > 0) {
    scene.time.delayedCall(autoHideMs, ()=>{
      scene.tweens.add({
        targets:bubble, alpha:0, duration:250,
        onComplete:()=>{
          if (bubble._follow) bubble._follow.remove(false);
          bubble.destroy(true);
          if (s4 && s4.bubble === bubble) s4.bubble = null;
        }
      });
    });
  }
}


  function _s4ShowSpotifyWidget(scene, onPlay){
  const s4 = scene._s4; if (!s4) return;

  if (s4.ui) s4.ui.destroy(true);
  if (s4.uiFollow) { s4.uiFollow.remove(false); s4.uiFollow = null; }

  const ui = scene.add.container(0,0).setDepth(6000);
  s4.ui = ui;

  const SONG_TITLE = "When it's time – Green Day";
  const OFFSET_Y = 0; // ajusta si quieres subir/bajar el popup (ej. -40)

  // Centro EXACTO de la escena (imagen base 'scene4') en coords de mundo
  const computePos = ()=>{
    const baseTex = scene.textures.get('scene4');
    const src = baseTex ? baseTex.getSourceImage() : null;
    const sx = s4.container.scaleX ?? 1;
    const sy = s4.container.scaleY ?? 1;

    // La base 'scene4' dentro del container usa origen (0.5, 1)
    const centerX = s4.container.x;
    let centerY = s4.container.y; // parte inferior en railY
    if (src) {
      const topY = s4.container.y - (src.height * sy);
      centerY = topY + (src.height * sy) * 0.5;
    }
    return { x: centerX, y: centerY + OFFSET_Y };
  };
  const p = computePos();

  // Card
  const CARD_W = 320, CARD_H = 72;
  const card = scene.add.rectangle(p.x, p.y, CARD_W, CARD_H, 0x121212, 0.96)
    .setOrigin(0.5)
    .setStrokeStyle(2, 0x1db954, 0.9);
  ui.add(card);

  // Album (falso)
  const album = scene.add.rectangle(p.x - CARD_W/2 + 12 + 24, p.y, 48, 48, 0x222222, 1)
    .setOrigin(0.5).setStrokeStyle(1, 0x444444, 1);
  ui.add(album);

  // Título
  const title = scene.add.text(
    p.x - CARD_W/2 + 12 + 24 + 32, p.y - 10,
    SONG_TITLE,
    { fontFamily:'monospace', fontSize:14, color:'#ffffff', wordWrap:{ width: CARD_W - 140 } }
  ).setOrigin(0,0.5);
  ui.add(title);

  // Botón Play
  const btnW=80, btnH=28;
  const playBg = scene.add.rectangle(p.x + CARD_W/2 - btnW/2 - 12, p.y + 12, btnW, btnH, 0x1db954, 1)
    .setOrigin(0.5);
  const playTx = scene.add.text(playBg.x, playBg.y, '▶ Play', {
    fontFamily:'monospace', fontSize:14, color:'#000000'
  }).setOrigin(0.5);
  ui.add(playBg); ui.add(playTx);

  // Click en toda la tarjeta
  [card, album, title, playBg, playTx].forEach(el=>{
    el.setInteractive({ useHandCursor:true });
    el.on('pointerdown', async ()=>{
      try{
        if (scene.sound.locked) scene.sound.unlock();
        if (scene.sound.context && scene.sound.context.state === 'suspended'){
          await scene.sound.context.resume();
        }
      }catch(e){}
      if (onPlay) onPlay();
    });
  });

  // Mantener el popup en el centro de la escena aunque cambie escala/resize
  s4.uiFollow = scene.time.addEvent({
    delay:16, loop:true, callback:()=>{
      const np = computePos();
      card.setPosition(np.x, np.y);
      album.setPosition(np.x - CARD_W/2 + 12 + 24, np.y);
      title.setPosition(np.x - CARD_W/2 + 12 + 24 + 32, np.y - 10);
      playBg.setPosition(np.x + CARD_W/2 - btnW/2 - 12, np.y + 12);
      playTx.setPosition(playBg.x, playBg.y);
    }
  });
}


 function _s4StartSong(scene){
  const s4 = scene._s4;
  if (!s4) return;

  // Apaga BGM/ambientes inmediatamente
  if (GameState.bgm && GameState.bgm.isPlaying) GameState.bgm.stop();
  if (scene.ambBirds && scene.ambBirds.isPlaying) scene.ambBirds.stop();
  if (scene.ambAtmo  && scene.ambAtmo.isPlaying)  scene.ambAtmo.stop();

  // Carga/crea canción
  if (!scene.cache.audio.exists('scene4_song')) {
    console.warn('[Scene4] Missing audio key "scene4_song" (check /assets/audio/greenday.mp3)');
    return;
  }
  if (!s4.song) {
    s4.song = scene.sound.add('scene4_song', { volume:0.20, loop:true });
  }

  // Limpieza UI/burbujas
  if (s4.ui) { s4.ui.destroy(true); s4.ui=null; }
  if (s4.uiFollow) { s4.uiFollow.remove(false); s4.uiFollow = null; }
  if (s4.bubble) { if (s4.bubble._follow) s4.bubble._follow.remove(false); s4.bubble.destroy(true); s4.bubble=null; }

  // Estado
  s4.song.play({ seek: 0 });
  s4.songPlaying = true;
  GameState.bgm = s4.song;

  // --- NUEVO: secuencia de diálogo con bloqueo de controles ---
  // Bloquea movimiento hasta que el NPC diga "Yo también te amo"
  scene._controlsLocked = true;
  s4.dialogTimers ||= [];

  // 1) A los 4s: NPC -> "¡Me encanta! ❤️"
  const t1 = scene.time.delayedCall(4000, () => {
    _s4ShowNpcBubble(scene, "¡Me encanta! ❤️");
  });

  // 2) ~1.2s después: Player -> "Te amo"
  const t2 = scene.time.delayedCall(4000 + 1200, () => {
    _s4ShowBubble(scene, "Te amo");
  });

  // 3) 2s después: NPC -> "Yo también te amo"
  const t3 = scene.time.delayedCall(4000 + 1200 + 2000, () => {
    _s4ShowNpcBubble(scene, "Yo también te amo");
  });

  // 4) Libera controles tras ~1.8s (coincide con auto-fade de burbujas)
  const t4 = scene.time.delayedCall(4000 + 1200 + 2000 + 1800, () => {
    scene._controlsLocked = false;
  });

  s4.dialogTimers.push(t1, t2, t3, t4);
}


  function _s4ShowNpcBubble(scene, text){
  const s4 = scene._s4; if (!s4) return;

  // limpiar si ya hay uno
  if (s4.npcBubble) {
    if (s4.npcBubble._follow) s4.npcBubble._follow.remove(false);
    s4.npcBubble.destroy(true);
  }

  // posición en MUNDO justo sobre la cabeza del NPC
  const npcW = _worldPos(scene, s4.container, s4.npc);
  const above = npcW.y - (s4.npc.displayHeight * s4.container.scaleY) - 16;

  const bubble = scene.add.text(
    npcW.x, above,
    text,
    { fontFamily:"monospace", fontSize:14, color:"#ffffff", backgroundColor:"#000000", align:"center" }
  ).setOrigin(0.5,1).setDepth(6500).setAlpha(0);

  s4.npcBubble = bubble;

  // fade-in
  scene.tweens.add({ targets:bubble, alpha:1, duration:200 });

  // que siga la cabeza del NPC
  bubble._follow = scene.time.addEvent({
    delay:16, loop:true, callback:()=>{
      const p = _worldPos(scene, s4.container, s4.npc);
      const y = p.y - (s4.npc.displayHeight * s4.container.scaleY) - 16;
      bubble.setPosition(p.x, y);
    }
  });

  // auto-desaparecer a los ~1.8s
  scene.time.delayedCall(1800, ()=>{
    scene.tweens.add({
      targets:bubble, alpha:0, duration:250,
      onComplete:()=>{
        if (bubble._follow) bubble._follow.remove(false);
        bubble.destroy(true);
        if (s4 && s4.npcBubble === bubble) s4.npcBubble = null;
      }
    });
  });
}


function _showPlayerBubble(scene, text, autoHideMs = 1800) {
  // kill previous if any
  if (scene._playerBubble) {
    if (scene._playerBubble._follow) scene._playerBubble._follow.remove(false);
    scene._playerBubble.destroy(true);
    scene._playerBubble = null;
  }

  const bubble = scene.add.text(
    scene.player.x,
    scene.player.y - scene.player.displayHeight - 40,
    text,
    { fontFamily:"monospace", fontSize:14, color:"#ffffff", backgroundColor:"#000000", align:"center" }
  ).setOrigin(0.5,1).setDepth(4000).setAlpha(0);

  scene._playerBubble = bubble;

  // fade in
  scene.tweens.add({ targets:bubble, alpha:1, duration:300, ease:'Sine.easeInOut' });

  // follow player
  bubble._follow = scene.time.addEvent({
    delay:16, loop:true, callback:()=>{
      bubble.setPosition(scene.player.x, scene.player.y - scene.player.displayHeight - 40);
    }
  });

  if (autoHideMs > 0) {
    scene.time.delayedCall(autoHideMs, ()=>{
      scene.tweens.add({
        targets:bubble, alpha:0, duration:250,
        onComplete:()=>{
          if (bubble._follow) bubble._follow.remove(false);
          bubble.destroy(true);
          if (scene._playerBubble === bubble) scene._playerBubble = null;
        }
      });
    });
  }
}


  // -------------------- ZONES (mini-scenes) --------------------
  const ZONE_DEFS = {
    1: {
      manifest: {
        images: [
          { key:'scene1', path:'/assets/scenes/scene1/scene1.png' },
          { key:'s1_gorrion', path:'/assets/scenes/scene1/extra/gorrion.png' },
          { key:'s1_gorrion_jump', path:'/assets/scenes/scene1/extra/gorrion_jump.png' },
          { key:'s1_gorriones', path:'/assets/scenes/scene1/extra/gorriones.png' }
        ]
      },
      build(scene, container){
        const who = GameState.character || 'joaquin';
        container.add(scene.add.image(80, -260, 's1_gorriones')
          .setOrigin(0.5,1).setScale(0.070).setDepth(1));

        const spar = scene.add.sprite(20,-10,'s1_gorrion')
          .setOrigin(0.5,1).setScale(0.080).setDepth(2);
        container.add(spar);

        let baseX = 20, t=0, phase="idle";
        let idleLeft = Phaser.Math.Between(1500, 3000);
        const dirPattern=[1,1,-1,1,-1,-1]; let patIdx=0;

        const ev = scene.time.addEvent({
          delay:16, loop:true, callback:()=>{
            if (!spar.active) return;
            if (phase==="idle") {
              idleLeft -= 16;
              if (idleLeft <= 0) { phase="hop"; t=0; spar.setTexture('s1_gorrion_jump'); }
            } else {
              t+=16;
              const p=Math.min(1,t/420); const eased=p*p*(3-2*p);
              const dir=dirPattern[patIdx];
              const endX=baseX+dir*12;
              spar.x=baseX+(endX-baseX)*eased;
              spar.y=-10 - (18)*4*p*(1-p);
              if (p>=1){ baseX=endX; spar.x=endX; spar.y=-10; spar.setTexture('s1_gorrion');
                patIdx=(patIdx+1)%dirPattern.length; phase="idle"; idleLeft=Phaser.Math.Between(1500, 3000); }
            }
          }
        });
        this._timers = [ev];

        const otherImgKey = (who === 'sofia') ? 'joaquin_idle' : 'sofia_idle';
        container.add(scene.add.image(180,-10, otherImgKey).setOrigin(0.5,1).setScale(0.5).setDepth(1));
      },

      enter(scene){
        if (GameState.sound) {
          if (scene.ambBirds && !scene.ambBirds.isPlaying) scene.ambBirds.play();
          if (scene.ambAtmo  && !scene.ambAtmo.isPlaying)  scene.ambAtmo.play();
        }
      },

      leave(scene){
        if (scene.thoughtBubble) scene.tweens.add({ targets: scene.thoughtBubble, alpha:0, duration:250 });
        (this._timers || []).forEach(t => { try{ t.remove(false); }catch{} });
        this._timers = [];

        if (scene.ambBirds && scene.ambBirds.isPlaying) scene.ambBirds.stop();
        if (scene.ambAtmo  && scene.ambAtmo.isPlaying)  scene.ambAtmo.stop();
      },

      update(scene){
        const b = scene._zoneBounds(1).center;
        const inRange = (scene.player.x >= b - 80 && scene.player.x <= b + 80);

        if (inRange && !scene._bubbleVisible) {
          scene._bubbleVisible = true;
          scene.tweens.add({ targets: scene.thoughtBubble, alpha:1, duration:400, ease:'Sine.easeInOut' });
        }
        if (!inRange && scene._bubbleVisible) {
          scene._bubbleVisible = false;
          scene.tweens.add({ targets: scene.thoughtBubble, alpha:0, duration:300, ease:'Sine.easeInOut' });
        }
      },
    },

   // -------- Scene 2: extras + (NPC = el otro personaje) --------
// -------- Scene 2: extras anim + singer + Joaquin guitar + LOCAL proximity bubble --------
// -------- Scene 2: extras + ONE NPC (the "other") + player speaks on proximity --------
2: {
  manifest: {
    images: [
      { key:'scene3',      path:'/assets/scenes/scene3/scene3.png' },
      { key:'s3_extras1',  path:'/assets/scenes/scene3/extra/extras_musica.png' },
      { key:'s3_extras2',  path:'/assets/scenes/scene3/extra/extras_musica2.png' },

      // Sofía singer (sheet: 3 frames horizontally)
      { key:'s2_singer_sheet', path:'/assets/sofia/scene2/sofia_canta.png' },

      // Joaquín guitar (3 separate PNGs; if one missing, anim still works)
      { key:'joaquin_guitar1', path:'/assets/joaquin/scene2/joaquin_guitar.png' },
      { key:'joaquin_guitar2', path:'/assets/joaquin/scene2/joaquin_guitar2.png' },
      { key:'joaquin_guitar3', path:'/assets/joaquin/scene2/joaquin_guitar3.png' },
    ]
  },

  // --- Local player bubble (independent of other scenes) ---
  _showPlayerBubble(scene, text, autoHideMs = 1800){
    if (this._pBubble) {
      try { this._pBubble._follow?.remove(false); } catch(_) {}
      this._pBubble.destroy(true);
      this._pBubble = null;
    }
    const bubble = scene.add.text(
      scene.player.x,
      scene.player.y - scene.player.displayHeight - 40,
      text,
      { fontFamily:'monospace', fontSize:14, color:'#ffffff', backgroundColor:'#000000', align:'center' }
    ).setOrigin(0.5,1).setDepth(6500).setAlpha(0);

    this._pBubble = bubble;

    scene.tweens.add({ targets:bubble, alpha:1, duration:200 });
    bubble._follow = scene.time.addEvent({
      delay:16, loop:true, callback:()=>{
        if (!bubble.active) return;
        bubble.setPosition(scene.player.x, scene.player.y - scene.player.displayHeight - 40);
      }
    });

    if (autoHideMs > 0){
      scene.time.delayedCall(autoHideMs, ()=>{
        scene.tweens.add({
          targets:bubble, alpha:0, duration:220,
          onComplete:()=>{
            try { bubble._follow?.remove(false); } catch(_) {}
            bubble.destroy(true);
            if (this._pBubble === bubble) this._pBubble = null;
          }
        });
      });
    }
  },

  build(scene, container){
    // Background extras
    const animKey = 's3_extras_anim';
    if (!scene.anims.exists(animKey)) {
      scene.anims.create({
        key: animKey,
        frames: [{ key:'s3_extras1' }, { key:'s3_extras2' }],
        frameRate: 3, repeat: -1, yoyo: true
      });
    }
    container.add(
      scene.add.sprite(-320, -10, 's3_extras1')
        .setOrigin(0.5,1).setScale(0.30).setDepth(2).play(animKey)
    );

    const who = GameState.character || 'joaquin';        // player
    const other = (who === 'sofia') ? 'joaquin' : 'sofia'; // the single NPC we’ll spawn

    let npcRef = null;

    // --- NPC = Sofía singer (only if player is Joaquín) ---
    if (other === 'sofia') {
      const img = scene.textures.get('s2_singer_sheet')?.getSourceImage();
      if (img){
        const framesAcross = 3;
        const frameWidth  = Math.round(img.width / framesAcross);
        const frameHeight = img.height;

        if (!scene.textures.exists('s2_singer')){
          scene.textures.addSpriteSheet('s2_singer', img, {
            frameWidth, frameHeight, endFrame: framesAcross - 1
          });
        }
        if (!scene.anims.exists('s2_singer_anim')){
          scene.anims.create({
            key:'s2_singer_anim',
            frames: scene.anims.generateFrameNumbers('s2_singer', { frames: [0,1,2,1] }),
            frameRate: 3, repeat: -1
          });
        }
        npcRef = scene.add.sprite(-60, 80, 's2_singer', 0)
          .setOrigin(0.5,1).setScale(0.40).setDepth(3).play('s2_singer_anim');
        container.add(npcRef);

        // gentle bob
        scene.tweens.add({ targets:npcRef, y:'-=4', duration:10000, yoyo:true, repeat:-1, ease:'Sine.easeInOut' });
      }
    }

    // --- NPC = Joaquín guitar (only if player is Sofía) ---
    if (other === 'joaquin') {
     const hasJ1 = scene.textures.exists('joaquin_guitar1');
     const hasJ2 = scene.textures.exists('joaquin_guitar2');
     const hasJ3 = scene.textures.exists('joaquin_guitar3');

const frames = [
  hasJ1 && { key:'joaquin_guitar1' },
  hasJ2 && { key:'joaquin_guitar2' },
  hasJ3 && { key:'joaquin_guitar3' },
].filter(Boolean);

      if (frames.length){
        if (frames.length === 1) frames.push(frames[0]); // ensure loopable
        if (!scene.anims.exists('joaquin_guitar_anim')){
          scene.anims.create({ key:'joaquin_guitar_anim', frames, frameRate:3, repeat:-1, yoyo:true });
        }
       npcRef = scene.add.sprite(220, -80, frames[0].key)
       .setOrigin(0.5,1).setScale(0.60).setDepth(3).setFlipX(true).play('joaquin_guitar_anim');
        container.add(npcRef);
      }
    }

    // Save scene2 state
    scene._s2 = {
      container,
      npcRef,
      npcRole: other,
      triggerRadius: 110,
      spokeOnce: false
    };
  },

  enter(scene){
    if (!scene._s2) return;
    this._pBubble && this._pBubble.destroy(true);
    this._pBubble = null;
    scene._s2.spokeOnce = false;
  },

  leave(scene){
    this._pBubble && this._pBubble.destroy(true);
    this._pBubble = null;
    scene._s2 = null;
  },

  update(scene){
    const s2 = scene._s2; if (!s2 || !s2.npcRef) return;

    // NPC faces player
    const npcW = _worldPos(scene, s2.container, s2.npcRef);
    s2.npcRef.setFlipX(scene.player.x < npcW.x);

    // Proximity → player says the line ONCE
    const dx = Math.abs(scene.player.x - npcW.x);
    if (!s2.spokeOnce && dx <= s2.triggerRadius) {
      s2.spokeOnce = true;

      const playerLine =
        (s2.npcRole === 'joaquin') ? 'Qué bonito toca la guitarra'
                                   : 'Qué lindo canta';

      this._showPlayerBubble(scene, playerLine, 1800);
    }
  },
},
    /* ===================== SCENE 3 ===================== */
    3: {
      manifest: { images:[ { key:'scene2', path:'/assets/scenes/scene2/scene2.png' } ] },

      build(scene, container){
        const baseImg = container.list.find(o => o.texture?.key?.startsWith('scene'));
        if (!baseImg) return;
        const pad = 12;
        const b = baseImg.getBounds();
        const left  = b.left  + pad;
        const right = b.right - pad;

        scene._npc3_bounds     = { left, right };
        scene._npc3_waitLeftX  = left;
        scene._npc3_waitRightX = right;
        scene._npc3_followGap  = 30;
        scene._npc3_lerp       = 0.20;

        const who   = GameState.character || 'joaquin';
        const other = (who === 'sofia') ? 'joaquin' : 'sofia';
        scene._npc3_other   = other;
        scene._npc3_walkKey = `npc3_walk_${other}`;

        if (!scene.anims.exists(scene._npc3_walkKey)) {
          scene.anims.create({
            key: scene._npc3_walkKey,
            frames: [1,2,3,4,5,6].map(i => ({ key: `${other}_walk${i}` })),
            frameRate: 12,
            repeat: -1
          });
        }

        if (!scene._npc3) {
          scene._npc3 = scene.add
            .sprite(scene._npc3_waitLeftX, scene.railY, `${other}_idle`)
            .setOrigin(0.5, 1)
            .setScale(0.2)
            .setDepth(999)
            .setFlipX(false);
          scene._npc3_mode = 'left_wait';
        } else {
          scene._npc3.setDepth(999).setScale(0.2);
          scene._npc3.x = Phaser.Math.Clamp(scene._npc3.x, left, right);
        }
      },

      enter(scene){
        const npc = scene._npc3, lim = scene._npc3_bounds;
        if (!npc || !lim) return;
        const px = scene.player.x;

        if (px >= lim.left && px <= lim.right) {
          const gap = scene.player.flipX ? -scene._npc3_followGap : scene._npc3_followGap;
          npc.x = Phaser.Math.Clamp(px + gap, lim.left, lim.right);
          npc.setFlipX(scene.player.flipX);
          scene._npc3_mode = 'follow';
          scene.isMoving ? npc.play(scene._npc3_walkKey, true)
                         : npc.setTexture(`${scene._npc3_other}_idle`);
        } else {
          if (px <  lim.left) { npc.x = scene._npc3_waitLeftX;  npc.setFlipX(false);  scene._npc3_mode = 'left_wait'; }
          if (px >  lim.right){ npc.x = scene._npc3_waitRightX; npc.setFlipX(true);   scene._npc3_mode = 'right_wait'; }
          npc.stop().setTexture(`${scene._npc3_other}_idle`);
        }
      },

      leave(scene){
        const npc = scene._npc3, lim = scene._npc3_bounds;
        if (npc && lim){
          const px = scene.player.x;
          if (px <= lim.left)  { npc.x = scene._npc3_waitLeftX;  npc.setFlipX(false);  scene._npc3_mode = 'left_wait'; }
          if (px >= lim.right) { npc.x = scene._npc3_waitRightX; npc.setFlipX(true);   scene._npc3_mode = 'right_wait'; }
          npc.stop().setTexture(`${scene._npc3_other}_idle`);
        }
      },

      update(scene){
        const npc = scene._npc3, lim = scene._npc3_bounds;
        if (!npc || !lim) return;

        const px = scene.player.x;

        if (px < lim.left) {
          scene._npc3_mode = 'left_wait';
          npc.x = scene._npc3_waitLeftX;
          npc.setFlipX(false);
          npc.stop().setTexture(`${scene._npc3_other}_idle`);
          return;
        }
        if (px > lim.right) {
          scene._npc3_mode = 'right_wait';
          npc.x = scene._npc3_waitRightX;
          npc.setFlipX(true);
          npc.stop().setTexture(`${scene._npc3_other}_idle`);
          return;
        }

        scene._npc3_mode = 'follow';
        const gap     = scene.player.flipX ? -scene._npc3_followGap : scene._npc3_followGap;
        const targetX = Phaser.Math.Clamp(px + gap, lim.left, lim.right);

        npc.x = Phaser.Math.Linear(npc.x, targetX, scene._npc3_lerp);
        npc.setFlipX(scene.player.flipX);

        if (scene.isMoving) {
          if (!npc.anims.currentAnim || npc.anims.currentAnim.key !== scene._npc3_walkKey) {
            npc.play(scene._npc3_walkKey, true);
          }
          const pf = scene.player.anims.currentFrame, na = npc.anims.currentAnim;
          if (pf && na && na.frames && na.frames[pf.index]) npc.anims.setCurrentFrame(na.frames[pf.index]);
        } else {
          npc.stop().setTexture(`${scene._npc3_other}_idle`);
        }
      },
    },

    // -------- Scene 4: Near NPC → bubble + Spotify-like widget; BGM keeps until Play --------
4: {
  manifest: {
    images: [
      { key: "scene4",         path: "/assets/scenes/scene4/scene4.png" },
      { key: "s4_bench",       path: "/assets/scenes/scene4/extra/bench.png" },
      { key: "s4_npc_sofia",   path: "/assets/sofia/casual/sofia_standing.png" },
      { key: "s4_npc_joaquin", path: "/assets/joaquin/casual/joaquin_standing.png" }
    ]
  },

  build(scene, container){
    const baseSrc = scene.textures.get("scene4").getSourceImage();
    const baseW   = baseSrc.width;

    // Bench
    const BENCH_REL_WIDTH = 0.250;
    const benchTexW  = scene.textures.get("s4_bench").getSourceImage().width;
    const benchScale = (BENCH_REL_WIDTH * baseW) / benchTexW;

    const bench = scene.add.sprite(0, -8, "s4_bench")
      .setOrigin(0.5, 1)
      .setScale(benchScale)
      .setDepth(3);
    container.add(bench);

    // --- NPC = the "other" character ---
    const who   = GameState.character || 'joaquin';           // player
    const other = (who === 'sofia') ? 'joaquin' : 'sofia';    // NPC
    const npcKey = (other === 'sofia') ? 's4_npc_sofia' : 's4_npc_joaquin';

    const NPC_REL_WIDTH = 0.080;
    const npcTexW  = scene.textures.get(npcKey).getSourceImage().width;
    const npcScale = (NPC_REL_WIDTH * baseW) / npcTexW;

    const npc = scene.add.sprite(0, 0, npcKey)
      .setOrigin(0.5, 1)
      .setScale(npcScale)
      .setDepth(4);
    container.add(npc);

    scene._s4 = {
      popupTimer: null,
      npcBubble: null,
      container,
      npc,
      stopGap: 10,
      triggerRadius: 110,
      ui: null,
      uiFollow: null,
      bubble: null,
      song: null,
      songPlaying: false,
      locking: false,
      // store original player scale when we tweak Sofía
      prevPlayerScale: null,
    };
  },

  leave(scene){
    // Clean UI and timers
    if (scene._s4?.ui) scene._s4.ui.destroy(true);
    if (scene._s4?.uiFollow) { scene._s4.uiFollow.remove(false); scene._s4.uiFollow = null; }
    if (scene._s4?.popupTimer) { try { scene._s4.popupTimer.remove(false); } catch(_){} scene._s4.popupTimer = null; }
    if (scene._s4?.bubble) {
      if (scene._s4.bubble._follow) scene._s4.bubble._follow.remove(false);
      scene._s4.bubble.destroy(true);
    }
    if (scene._s4?.dialogTimers && Array.isArray(scene._s4.dialogTimers)) {
      scene._s4.dialogTimers.forEach(t => { try { t.remove(false); } catch(_){} });
    }
    if (scene._s4?.npcBubble) {
      if (scene._s4.npcBubble._follow) scene._s4.npcBubble._follow.remove(false);
      scene._s4.npcBubble.destroy(true);
    }

    // Stop scene song if playing
    if (scene._s4?.song && scene._s4.song.isPlaying) scene._s4.song.stop();

    // If GameState.bgm was hijacked by scene song, restore base BGM
    if (GameState.bgm === scene._s4?.song) {
      GameState.bgm = scene.sound.add('bgm', { loop:true, volume: 0.10 });
      if (GameState.sound) { try { GameState.bgm.play(); } catch(_) {} }
    }

    // Restore Sofía (player) original scale if we changed it here
    if (scene._s4?.prevPlayerScale) {
      scene.player.setScale(scene._s4.prevPlayerScale.x, scene._s4.prevPlayerScale.y);
    }

    // Reset locks
    scene._s4 = null;
    scene._controlsLocked = false;
    scene._lockStopX = null;
  },

  update(scene){
    const s4 = scene._s4;
    if (!s4) return;

    // WORLD coordinates for NPC vs PLAYER
    const npcW = _worldPos(scene, s4.container, s4.npc);
    const px   = scene.player.x;
    const dx   = Math.abs(px - npcW.x);

    // NPC looks at player
    s4.npc.setFlipX(px < npcW.x);

    if (s4.songPlaying) return;

    // Show bubble + widget when very close
    const near = dx <= s4.triggerRadius;
    if (near && !s4.locking) {
      s4.locking = true;
      scene._controlsLocked = true;
      scene._lockStopX = (px < npcW.x) ? (npcW.x - s4.stopGap) : (npcW.x + s4.stopGap);

      // NPC speaks first
      _s4ShowNpcBubble(scene, "Quiero mostrarte esta canción");

      // After 3s, show the Spotify-like widget
      if (s4.popupTimer) { try { s4.popupTimer.remove(false); } catch(_){} }
      s4.popupTimer = scene.time.delayedCall(3000, () => {
        if (s4 && s4.locking && !s4.ui && !s4.songPlaying) {
          _s4ShowSpotifyWidget(scene, () => _s4StartSong(scene));
        }
      });
    }

    // Move away → cancel + clean
    if (!near && s4.locking) {
      s4.locking = false;
      scene._controlsLocked = false;
      scene._lockStopX = null;

      if (s4.popupTimer) { try { s4.popupTimer.remove(false); } catch(_){} s4.popupTimer = null; }

      if (s4.bubble) scene.tweens.add({
        targets: s4.bubble, alpha: 0, duration: 250,
        onComplete: () => {
          if (s4.bubble?._follow) s4.bubble._follow.remove(false);
          s4.bubble?.destroy(true);
          s4.bubble = null;
        }
      });
      if (s4.ui) { s4.ui.destroy(true); s4.ui = null; }
      if (s4.uiFollow) { s4.uiFollow.remove(false); s4.uiFollow = null; }
    }
  },
},

    /* ===================== SCENE 5 ===================== */
5: {
  manifest: {
    images: [
      { key: 'scene5',         path: '/assets/scenes/scene5/scene5.png' },
      { key: 's4_npc_sofia',   path: '/assets/sofia/casual/sofia_standing.png' },
      { key: 's4_npc_joaquin', path: '/assets/joaquin/casual/joaquin_standing.png' },

      // Loky (sitting + walk frames)
      { key: 's5_loky_sit',  path: '/assets/loky/loky_sitting.png' },
      { key: 'loky_walk1',   path: '/assets/loky/loky_walk1.png' },
      { key: 'loky_walk2',   path: '/assets/loky/loky_walk2.png' },
      { key: 'loky_walk3',   path: '/assets/loky/loky_walk3.png' },
      { key: 'loky_walk4',   path: '/assets/loky/loky_walk4.png' }
    ]
  },

  build(scene, container){
    const baseImg = scene.textures.get('scene5').getSourceImage();
    const baseW   = baseImg.width;

    // -------- Tunables --------
    const NPC_REL_W        = 0.085;
    const LOKY_REL_W       = 0.045;
    const FOLLOW_GAP       = 28;
    const LERP_FOLLOW      = 0.20;
    const APPROACH_SPEED   = 120;  // px/s for first approach
    const MOVE_EPS         = 0.02;

    // Dialog trigger
    const TRIGGER_RADIUS   = 110;
    const STOP_GAP         = 14;
    // --------------------------

    const who   = GameState.character || 'joaquin';            // player
    const other = (who === 'sofia') ? 'joaquin' : 'sofia';     // NPC
    const npcKey = (other === 'sofia') ? 's4_npc_sofia' : 's4_npc_joaquin';

    // NPC
    const npcTexW = scene.textures.get(npcKey).getSourceImage().width;
    const npc = scene.add.sprite(0, 0, npcKey)
      .setOrigin(0.5, 1)
      .setScale((NPC_REL_W * baseW) / npcTexW)
      .setDepth(4);
    container.add(npc);

    // Gentle idle bob
    scene.tweens.add({ targets: npc, y: '-=3', duration: 2200, yoyo: true, repeat: -1, ease: 'Sine.easeInOut' });

    // Loky
    const sitKey = scene.textures.exists('s5_loky_sit') ? 's5_loky_sit' : 'loky_walk1';
    const lokyW  = scene.textures.get(sitKey).getSourceImage().width;
    const loky   = scene.add.sprite(-baseW * 0.35, 0, sitKey)
      .setOrigin(0.5, 1)
      .setScale((LOKY_REL_W * baseW) / lokyW)
      .setDepth(3);
    container.add(loky);

    // Loky walk anim (robust to missing frames)
    const frames = ['loky_walk1','loky_walk2','loky_walk3','loky_walk4'].filter(k => scene.textures.exists(k));
    let walkKey = null;
    if (frames.length >= 2 && !scene.anims.exists('loky_walk_anim')) {
      scene.anims.create({ key: 'loky_walk_anim', frames: frames.map(k => ({ key:k })), frameRate: 12, repeat: -1 });
      walkKey = 'loky_walk_anim';
    } else if (scene.anims.exists('loky_walk_anim')) {
      walkKey = 'loky_walk_anim';
    }

    // World bounds for this scene
    const sx = container.scaleX || 1;
    const halfWorld = (baseW * sx) * 0.5;
    const leftBoundWorld  = container.x - halfWorld;
    const rightBoundWorld = container.x + halfWorld;

    // Save scene state
    scene._s5 = {
      container,
      npc,
      loky,

      // Loky movement
      sitKey,
      walkKey,
      followGap: FOLLOW_GAP,
      lerp: LERP_FOLLOW,
      approachSpeed: APPROACH_SPEED,
      moveEps: MOVE_EPS,

      // Bounds
      leftBoundWorld,
      rightBoundWorld,

      // Dialog
      stopGap: STOP_GAP,
      triggerRadius: TRIGGER_RADIUS,
      didIntro: false,
      _dlg1: null,
      _dlg2: null,

      // Loop handle
      loopEvt: null,

      // For one-shot follow transition
      mode: 'idle',
      promoted: false,
    };
  },

  enter(scene){
    const s5 = scene._s5; if (!s5) return;

    // Recompute bounds on entry (resizes etc.)
    const baseImg = scene.textures.get('scene5').getSourceImage();
    const sx = s5.container.scaleX || 1;
    const halfWorld = (baseImg.width * sx) * 0.5;
    s5.leftBoundWorld  = s5.container.x - halfWorld;
    s5.rightBoundWorld = s5.container.x + halfWorld;

    // Promote Loky to world space once (so he can leave container bounds cleanly)
    if (!s5.promoted) {
      const sxC = s5.container.scaleX || 1;
      const worldX = s5.container.x + s5.loky.x * sxC;
      s5.container.remove(s5.loky);
      s5.loky.x = worldX;
      s5.loky.y = scene.railY;
      s5.loky.setScale(s5.loky.scaleX * sxC, s5.loky.scaleY * sxC);
      scene.add.existing(s5.loky);
      s5.promoted = true;
    }

    // Reset state
    s5.loky.setTexture(s5.sitKey);
    s5.mode = 'idle';
    s5.didIntro = false;
    if (s5._dlg1) { try{s5._dlg1.remove(false);}catch{} s5._dlg1=null; }
    if (s5._dlg2) { try{s5._dlg2.remove(false);}catch{} s5._dlg2=null; }

    // Main loop: NPC facing, dialog trigger, Loky follow
    if (s5.loopEvt) { try { s5.loopEvt.remove(false); } catch(_) {} }
    s5.loopEvt = scene.time.addEvent({
      delay: 16,
      loop: true,
      callback: () => {
        // --- NPC faces player (use NPC world X, not container center) ---
        const npcW = _worldPos(scene, s5.container, s5.npc);
        s5.npc.setFlipX(scene.player.x < npcW.x);

        // --- One-time dialog: Joaquin asks first, Sofía responds (regardless of who is player) ---
        if (!s5.didIntro) {
          const nearNpc = Math.abs(scene.player.x - npcW.x) <= s5.triggerRadius;
          if (nearNpc) {
            s5.didIntro = true;

            // Lock & stop player close to NPC
            scene._controlsLocked = true;
            scene._lockStopX = (scene.player.x < npcW.x) ? (npcW.x - s5.stopGap) : (npcW.x + s5.stopGap);

            // Route NPC bubbles to "other" (the NPC)
            scene._s4 = { container: s5.container, npc: s5.npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };

            const playerIsJoaquin = (GameState.character || 'joaquin') === 'joaquin';

            // Joaquin asks
            if (playerIsJoaquin) {
              _showPlayerBubble(scene, "¿Ahora tenemos un perrito!?");
            } else {
              _s4ShowNpcBubble(scene, "¿Ahora tenemos un perrito!?"); // NPC = Joaquín
            }

            // Sofía responds after 1.2s
            s5._dlg1 = scene.time.delayedCall(1200, () => {
              if (playerIsJoaquin) {
                _s4ShowNpcBubble(scene, "Te presento a Locky."); // NPC = Sofía
              } else {
                _showPlayerBubble(scene, "Te presento a Locky.");
              }
            });

            // Unlock after another 1.2s (lets bubbles fade naturally)
            s5._dlg2 = scene.time.delayedCall(2400, () => {
              scene._controlsLocked = false;
              scene._lockStopX = null;
            });
          }
        }

        // --- Loky: stay parked at edge if player is outside this scene's bounds ---
        const inside = (scene.player.x >= s5.leftBoundWorld && scene.player.x <= s5.rightBoundWorld);
        if (!inside) {
          const atLeft = scene.player.x < s5.leftBoundWorld;
          s5.loky.x = atLeft ? s5.leftBoundWorld : s5.rightBoundWorld;
          if (s5.loky.anims?.isPlaying) s5.loky.stop();
          s5.loky.setTexture(s5.sitKey);
          s5.loky.setFlipX(scene.player.x < s5.loky.x);
          s5.mode = 'idle';
          return;
        }

        // First entry into bounds → approach once then follow
        if (s5.mode === 'idle') s5.mode = 'approachOnce';

        // Desired spot near player
        const gap      = s5.followGap;
        const targetX  = scene.player.x + (scene.player.flipX ? -gap : gap);
        const desiredX = Phaser.Math.Clamp(targetX, s5.leftBoundWorld, s5.rightBoundWorld);

        // Face movement direction
        s5.loky.setFlipX(desiredX < s5.loky.x);

        // Move with either approach speed or lerp follow
        const prevX = s5.loky.x;
        let nextX   = prevX;
        if (s5.mode === 'approachOnce') {
          const step = s5.approachSpeed * (16/1000);
          const delta = Phaser.Math.Clamp(desiredX - prevX, -step, step);
          nextX = prevX + delta;
        } else {
          nextX = Phaser.Math.Linear(prevX, desiredX, s5.lerp);
        }

        // Animate walk while moving, idle when not
        const moved = Math.abs(nextX - prevX) > s5.moveEps;
        if (moved) {
          if (s5.walkKey && (!s5.loky.anims.currentAnim || s5.loky.anims.currentAnim.key !== s5.walkKey)) {
            s5.loky.play(s5.walkKey, true);
          }
          // Optional: sync gait to player when player is moving
          if (scene.isMoving && scene.player.anims?.currentAnim && s5.loky.anims?.currentAnim) {
            const pf = scene.player.anims.currentFrame, da = s5.loky.anims.currentAnim;
            if (pf && da && da.frames && da.frames.length > 0) {
              const idx = pf.index % da.frames.length;
              if (da.frames[idx]) s5.loky.anims.setCurrentFrame(da.frames[idx]);
            }
          }
        } else {
          if (s5.loky.anims?.isPlaying) s5.loky.stop();
          s5.loky.setTexture(s5.sitKey);
        }

        s5.loky.x = nextX;

        // Switch mode when close enough to desired spot
        if (s5.mode === 'approachOnce' && Math.abs(desiredX - nextX) <= (s5.moveEps * 2)) {
          s5.mode = 'follow';
        }
      }
    });
  },

  leave(scene){
    const s5 = scene._s5; if (!s5) return;

    if (s5._dlg1) { try{s5._dlg1.remove(false);}catch{} s5._dlg1 = null; }
    if (s5._dlg2) { try{s5._dlg2.remove(false);}catch{} s5._dlg2 = null; }
    if (s5.loopEvt) { try{s5.loopEvt.remove(false);}catch{} s5.loopEvt = null; }

    // Park Loky at nearest edge & idle
    s5.loky.x = Phaser.Math.Clamp(s5.loky.x, s5.leftBoundWorld, s5.rightBoundWorld);
    if (s5.loky.anims?.isPlaying) s5.loky.stop();
    s5.loky.setTexture(s5.sitKey);

    scene._controlsLocked = false;
    scene._lockStopX = null;

    scene._s5 = null;
  },

  update(){ /* handled by loopEvt */ }
},

/* ===================== SCENE 6 — Sofía seated; Joaquín auto-walks to chair ===================== */
6: {
  manifest: {
    images: [
      { key: 'scene6',              path: '/assets/scenes/scene6/scene6.png' },

      // Sofía (seated triplet)
      { key: 's6_sofia_seated',     path: '/assets/sofia/casual/sofia_seated.png'  },
      { key: 's6_sofia_seated2',    path: '/assets/sofia/casual/sofia_seated2.png' },
      { key: 's6_sofia_seated3',    path: '/assets/sofia/casual/sofia_seated3.png' },

      // Joaquín (seated triplet) — if your project uses different paths, adjust here.
      { key: 's6_joaquin_seated',   path: '/assets/joaquin/casual/joaquin_seated.png'  },
     
      // Drone
      { key: 's6_drone', path: '/assets/scenes/scene6/extra/drone.png' }
    ]
  },

  build(scene, container){
    // --- Tunables ---
    const SOFIA_SEAT_REL_X =  0.30;   // right chair (fraction of bg width from center)
    const SOFIA_SEAT_REL_Y = -90;     // px above rail (container origin is bottom-center)
    const NPC_REL_W        =  0.140;  // seated sprite width relative to bg width

    const TRIGGER_RADIUS   = 120;     // when player is this close → stop & chat
    const STOP_GAP         =  18;     // how close in front of NPC the player stops

    // Drone path/sizing
    const DRONE_REL_W  = 0.100;
    const DRONE_RX_REL = 0.35;
    const DRONE_RY_REL = 0.18;
    const DRONE_SPEED  = 0.20;    // radians per second
    const DRONE_CX_REL = 0.05;
    const DRONE_CY_REL = -0.28;
    // -----------------

    const baseTex = scene.textures.get('scene6');
    const src     = baseTex.getSourceImage();
    const baseW   = src.width;

    // --- Decide who is NPC (seated) based on who the player is ---
    const playerIsSofia = (GameState.character || 'joaquin') === 'sofia';

    // Prefer Joaquín-seated set when player is Sofía; otherwise Sofía-seated set.
    const joaquinSet = ['s6_joaquin_seated'];
    const sofiaSet   = ['s6_sofia_seated','s6_sofia_seated2','s6_sofia_seated3'];

    // Check availability (graceful fallback to Sofía if Joaquín frames are missing)
    const hasJoaquin = joaquinSet.every(k => scene.textures.exists(k));
    const npcFrames  = playerIsSofia && hasJoaquin ? joaquinSet : sofiaSet;

    // Create (or reuse) a toast animation unique to this chosen set
    const toastKey = `s6_npc_toast_${npcFrames[0]}`;
    if (!scene.anims.exists(toastKey)) {
      scene.anims.create({
        key: toastKey,
        frames: [
          { key: npcFrames[0] },
          { key: npcFrames[1] },
          { key: npcFrames[2] },
          { key: npcFrames[1] },
          { key: npcFrames[0] },
        ],
        frameRate: 7,
        repeat: 0
      });
    }

    // --- NPC (idle seated) ---
    const npcBaseW = scene.textures.get(npcFrames[0]).getSourceImage().width;
    const npcScale = (NPC_REL_W * baseW) / npcBaseW;

    const seatLocalX = baseW * SOFIA_SEAT_REL_X;
    const seatLocalY = SOFIA_SEAT_REL_Y;

    const npc = scene.add.sprite(seatLocalX, seatLocalY, npcFrames[0])
      .setOrigin(0.5, 1)
      .setScale(npcScale)
      .setDepth(5)
      .setFlipX(true);
    container.add(npc);

    // --- DRONE ---
    const dImgW   = scene.textures.get('s6_drone').getSourceImage().width;
    const dScale  = (DRONE_REL_W * baseW) / dImgW;

    const drone = scene.add
      .sprite(0, 0, 's6_drone')
      .setOrigin(0.5)
      .setScale(dScale)
      .setDepth(6);
    container.add(drone);

    // --- Scene 6 state ---
    scene._s6 = {
      container,
      npc,
      npcFrames,
      toastKey,

      // player-stop logic
      triggerRadius: TRIGGER_RADIUS,
      stopGap: STOP_GAP,
      timers: [],
      locking: false,
      doneOnce: false,

      // world helpers for NPC
      npcWorldX(){
        const sx = container.scaleX || 1;
        return container.x + seatLocalX * sx;
      },
      npcWorldY(){
        const sy = container.scaleY || 1;
        return scene.railY + seatLocalY * sy;
      },

      // drone state (container-local coords)
      drone,
      drone_t: Math.random() * Math.PI * 2,
      drone_speed: DRONE_SPEED,
      drone_rx: baseW * DRONE_RX_REL,
      drone_ry: baseW * DRONE_RY_REL,
      drone_cx: baseW * DRONE_CX_REL,
      drone_cy: baseW * DRONE_CY_REL,
    };

    // Bubble proxy so _s4* helpers work here too
    scene._s4 = { container, npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };
    scene._s4_from6 = true;
  },

  enter(scene){
    const s6 = scene._s6; if (!s6) return;

    // Refresh bubble proxy on re-entry
    scene._s4 = { container: s6.container, npc: s6.npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };
    scene._s4_from6 = true;

    // Reset state
    (s6.timers||[]).forEach(t=>{ try{ t.remove(false); }catch{} });
    s6.timers   = [];
    s6.locking  = false;
    s6.doneOnce = false;
  },

  leave(scene){
    const s6 = scene._s6; if (s6){
      (s6.timers||[]).forEach(t=>{ try{ t.remove(false); }catch{} });
      s6.timers = [];
      s6.locking = false;
    }
    scene._controlsLocked = false;
    scene._lockStopX = null;

    // Clean the proxy
    if (scene._s4_from6 && scene._s4) {
      try {
        if (scene._s4.bubble?.destroy)    scene._s4.bubble.destroy(true);
        if (scene._s4.npcBubble?.destroy) scene._s4.npcBubble.destroy(true);
      } catch(_) {}
      delete scene._s4_from6;
      delete scene._s4;
    }
  },

  update(scene, dt = 0.016){
    const s6 = scene._s6; if (!s6) return;

    // --- DRONE: animate along an ellipse with a gentle bob/tilt ---
    if (s6.drone) {
      s6.drone_t += s6.drone_speed * dt;
      const a  = s6.drone_t;
      const x  = s6.drone_cx + s6.drone_rx * Math.cos(a);
      const y  = s6.drone_cy + s6.drone_ry * Math.sin(a) + 6 * Math.sin(a * 3);
      s6.drone.setPosition(x, y);

      const dx = -s6.drone_rx * Math.sin(a);
      s6.drone.setFlipX(dx < 0);
      s6.drone.rotation = 0.06 * Math.sin(a * 2);
    }

    // --- NPC faces the player ---
    const npcX = s6.npcWorldX();
    s6.npc.setFlipX(scene.player.x < npcX);

    // SAFETY: ensure the bubble proxy points at the current NPC
    if (!scene._s4 || scene._s4.npc !== s6.npc) {
      scene._s4 = { container: s6.container, npc: s6.npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };
      scene._s4_from6 = true;
    }

    // Stop if we already ran the toast+chat once this entry
    if (s6.doneOnce) return;

    // --- Proximity → lock, stop, toast & chat ---
    const dxP = Math.abs(scene.player.x - npcX);
    if (!s6.locking && dxP <= s6.triggerRadius) {
      s6.locking = true;
      scene._controlsLocked = true;
      scene._lockStopX = (scene.player.x < npcX) ? (npcX - s6.stopGap) : (npcX + s6.stopGap);

      // Freeze player in idle
      const who = GameState.character || 'joaquin';
      scene.player.stop().setTexture(scene._idleKey || `${who}_idle`);
      scene.isMoving = false;

      // One-shot cheers (chosen set)
      s6.npc.play(s6.toastKey);

      // Chat bubbles (same lines; NPC speaks first)
      const timers = [];
      timers.push(scene.time.delayedCall(300, () => {
        _s4ShowNpcBubble(scene, "Feliz aniversario, amor");
      }));
      timers.push(scene.time.delayedCall(300 + 1400, () => {
        _s4ShowBubble(scene, "Feliz aniversario");
      }));
      // Unlock after player line fades (~1.8s)
      timers.push(scene.time.delayedCall(300 + 1400 + 1800, () => {
        s6.doneOnce = true;
        s6.locking = false;
        scene._controlsLocked = false;
        scene._lockStopX = null;
      }));

      s6.timers = timers;
    }
  },
},
/* ===================== SCENE 7 — Sofía center + Loky sitting + Nala follower ===================== */
7: {
  manifest: {
    images: [
      { key:'scene7',       path:'/assets/scenes/scene7/scene7.png' },

      // NPC variants (we’ll pick depending on who’s playable)
      { key:'s7_sofia',     path:'/assets/sofia/casual/sofia_standing.png' },
      { key:'s7_joaquin',   path:'/assets/joaquin/casual/joaquin_standing.png' },

      // Loky (sitting)
      { key:'s7_lokySit',   path:'/assets/loky/loky_sitting.png' },

      // Nala (robust to your filenames; standing preferred)
      { key:'nala_walk1',   path:'/assets/nala/nala_walking1.png' },
      { key:'nala_walk2',   path:'/assets/nala/nala_walking2.png' },
      { key:'nala_walk3',   path:'/assets/nala/nala_walking3.png' },
      { key:'nala_stand',   path:'/assets/nala/nala_standing.png' },
      // (Optional alt stand) { key:'nala_stand2', path:'/assets/nala/nala_standing2.png' },
    ]
  },

  build(scene, container){
    // ----- Base sizes -----
    const baseImg = scene.textures.get('scene7').getSourceImage();
    const baseW   = baseImg.width;

    // ----- Tunables -----
    const NPC_REL_W        = 0.085;   // Sofia/Joaquin width vs bg
    const NPC_IDLE_BOB_PX  = 3;       // subtle breathing
    const LOKY_REL_W       = 0.035;
    const LOKY_OFFSET_X    = 70;      // px from NPC (container-local, pre-scale)

    const TRIGGER_RADIUS   = 140;     // when player is this close → stop & dialog
    const STOP_GAP         =  22;     // where player stops relative to NPC

    // Nala follower (scene5-like)
    const NALA_REL_W       = 0.090;
    const NALA_FOLLOW_GAP  = 26;
    const NALA_LERP        = 0.20;
    const NALA_APPROACH    = 120;     // px/s on first approach
    const NALA_MOVE_EPS    = 0.02;
    // ---------------------

    // ----- Decide who is playable & who is NPC -----
    // If Sofía is the playable character → NPC = Joaquín; else NPC = Sofía.
    const playableIsSofia = (GameState.character === 'sofia');
    const npcKey = playableIsSofia
      ? (scene.textures.exists('s7_joaquin') ? 's7_joaquin' : 's7_sofia')  // fallback if Joaquin art missing
      : 's7_sofia';

    const npcW  = scene.textures.get(npcKey).getSourceImage().width;
    const npc   = scene.add.sprite(0, 0, npcKey)
      .setOrigin(0.5, 1)
      .setScale((NPC_REL_W * baseW) / npcW)
      .setDepth(5);
    container.add(npc);

    // Idle bob for NPC
    scene.tweens.add({
      targets: npc,
      y: `-=${NPC_IDLE_BOB_PX}`,
      duration: 2200,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });

    // Loky sitting next to NPC
    const lokyW = scene.textures.get('s7_lokySit').getSourceImage().width;
    const loky  = scene.add.sprite(LOKY_OFFSET_X, 0, 's7_lokySit')
      .setOrigin(0.5, 1)
      .setScale((LOKY_REL_W * baseW) / lokyW)
      .setDepth(4);
    container.add(loky);

    // ----- NALA (build anim + sprite with fallbacks) -----
    // Choose idle frame (standing preferred; fallback to walk1)
    const idleKey = scene.textures.exists('nala_stand') ? 'nala_stand'
                  : (scene.textures.exists('nala_stand2') ? 'nala_stand2' : 'nala_walk1');

    // Create walk animation robustly
    if (!scene.anims.exists('nala_walk_anim')) {
      const has = k => scene.textures.exists(k);
      const raw = [];
      if (has('nala_walk1')) raw.push({ key:'nala_walk1' });
      if (has('nala_walk2')) raw.push({ key:'nala_walk2' });
      if (has('nala_walk3')) raw.push({ key:'nala_walk3' });

      // Fallbacks so animation always exists
      if (raw.length === 0) raw.push({ key: idleKey });
      if (raw.length === 1) raw.push(raw[0]); // at least 2 frames

      // Ping-pong walk: 1→2→3→2→loop (if 3 frames exist)
      const frames = (raw.length >= 3) ? [raw[0], raw[1], raw[2], raw[1]] : raw;

      scene.anims.create({
        key: 'nala_walk_anim',
        frames,
        frameRate: 10,
        repeat: -1
      });
    }

    const nW = scene.textures.get(idleKey).getSourceImage().width;
    const nala = scene.add.sprite(-baseW * 0.35, 0, idleKey)
      .setOrigin(0.5, 1)
      .setScale((NALA_REL_W * baseW) / nW)
      .setDepth(4);
    container.add(nala);

    // ----- Save state -----
    scene._s7 = {
      container, npc, loky,

      // dialog triggers
      triggerRadius: TRIGGER_RADIUS,
      stopGap: STOP_GAP,
      dialogDone: false,
      timers: [],

      // Nala follower state
      nala,
      nala_promoted: false,
      nala_idleKey: idleKey,
      nala_followGap: NALA_FOLLOW_GAP,
      nala_lerp: NALA_LERP,
      nala_approachSpeed: NALA_APPROACH,
      nala_moveEps: NALA_MOVE_EPS,
      nala_mode: 'idle', // 'idle' → 'approachOnce' → 'follow'
      nala_leftBoundWorld: 0,
      nala_rightBoundWorld: 0,
    };
  },

  enter(scene){
    const s7 = scene._s7; if (!s7) return;

    // Recompute world bounds (resize safe)
    const baseImg = scene.textures.get('scene7').getSourceImage();
    const sx = s7.container.scaleX || 1;
    const halfWorld = (baseImg.width * sx) * 0.5;
    s7.nala_leftBoundWorld  = s7.container.x - halfWorld;
    s7.nala_rightBoundWorld = s7.container.x + halfWorld;

    // Promote Nala to world space (so she follows independently of parallax)
    if (!s7.nala_promoted) {
      const sxC = s7.container.scaleX || 1;
      const worldX = s7.container.x + s7.nala.x * sxC;

      s7.container.remove(s7.nala);
      s7.nala.x = worldX;
      s7.nala.y = scene.railY;
      s7.nala.setScale(s7.nala.scaleX * sxC, s7.nala.scaleY * sxC);
      scene.add.existing(s7.nala);
      s7.nala_promoted = true;
    }

    // Reset dialog & nala to idle
    s7.dialogDone = false;
    s7.nala.setTexture(s7.nala_idleKey);
    s7.nala_mode = 'idle';

    // Make sure bubble proxy points at the current NPC
    scene._s4 = { container: s7.container, npc: s7.npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };
  },

  leave(scene){
    const s7 = scene._s7;
    if (s7) {
      (s7.timers||[]).forEach(t => { try { t.remove(false); } catch(_){} });
      s7.timers = [];

      // Park Nala at nearest edge + idle
      s7.nala.x = Phaser.Math.Clamp(s7.nala.x, s7.nala_leftBoundWorld, s7.nala_rightBoundWorld);
      if (s7.nala.anims?.isPlaying) s7.nala.stop();
      s7.nala.setTexture(s7.nala_idleKey);
    }
    scene._s7 = null;
  },

  update(scene, dt = 0.016){
    const s7 = scene._s7; if (!s7) return;

    // Face NPC & Loky toward player
    const sx = s7.container.scaleX || 1;
    const npcWorldX = s7.container.x + (s7.npc.x * sx);
    const playerLeft = scene.player.x < npcWorldX;
    s7.npc.setFlipX(playerLeft);
    s7.loky.setFlipX(playerLeft);

    // Ensure bubble proxy aims at NPC (safety on reloads)
    if (!scene._s4 || scene._s4.npc !== s7.npc) {
      scene._s4 = { container: s7.container, npc: s7.npc, ui:null, uiFollow:null, bubble:null, npcBubble:null };
    }

    // ---------- Dialog trigger ----------
    if (!s7.dialogDone && Math.abs(scene.player.x - npcWorldX) <= s7.triggerRadius) {
      s7.dialogDone = true;

      // Lock player & stop near NPC
      scene._controlsLocked = true;
      scene._lockStopX = (scene.player.x < npcWorldX)
        ? (npcWorldX - s7.stopGap)
        : (npcWorldX + s7.stopGap);

      // Freeze player in idle
      const who = GameState.character || 'joaquin';
      scene.player.stop().setTexture(scene._idleKey || `${who}_idle`);
      scene.isMoving = false;

      // NPC speaks first
      _s4ShowNpcBubble(scene, "Ahora somos 4");

      // After ~2s, both say “¡Bienvenida Nala!” simultaneously
      const t1 = scene.time.delayedCall(2000, () => {
        _s4ShowNpcBubble(scene, "¡Bienvenida Nala!");
        _s4ShowBubble(scene, "¡Bienvenida Nala!");
      });

      // Unlock controls after both lines fade (~ additional 2.2s)
      const t2 = scene.time.delayedCall(4200, () => {
        scene._controlsLocked = false;
        scene._lockStopX = null;
      });

      s7.timers = [t1, t2];
    }

    // ---------- Nala follower ----------
    const inside = (
      scene.player.x >= s7.nala_leftBoundWorld &&
      scene.player.x <= s7.nala_rightBoundWorld
    );

    if (!inside) {
      // park at nearest edge & idle
      const atLeft = scene.player.x < s7.nala_leftBoundWorld;
      s7.nala.x = atLeft ? s7.nala_leftBoundWorld : s7.nala_rightBoundWorld;
      if (s7.nala.anims?.isPlaying) s7.nala.stop();
      s7.nala.setTexture(s7.nala_idleKey);
      s7.nala.setFlipX(scene.player.x < s7.nala.x);
      s7.nala_mode = 'idle';
      return;
    }

    if (s7.nala_mode === 'idle') s7.nala_mode = 'approachOnce';

    // Desired spot near player
    const gap      = s7.nala_followGap;
    const targetX  = scene.player.x + (scene.player.flipX ? -gap : gap);
    const desiredX = Phaser.Math.Clamp(targetX, s7.nala_leftBoundWorld, s7.nala_rightBoundWorld);

    // Face movement dir
    s7.nala.setFlipX(desiredX < s7.nala.x);

    // Move
    const prevX = s7.nala.x;
    let nextX   = prevX;

    if (s7.nala_mode === 'approachOnce') {
      const step  = s7.nala_approachSpeed * dt;
      const delta = Phaser.Math.Clamp(desiredX - prevX, -step, step);
      nextX = prevX + delta;
    } else {
      nextX = Phaser.Math.Linear(prevX, desiredX, s7.nala_lerp);
    }

    const moved = Math.abs(nextX - prevX) > (s7.nala_moveEps * 0.5); // slightly looser
    if (moved) {
      // Ensure walk animation is playing
      if (!s7.nala.anims?.isPlaying || s7.nala.anims.currentAnim?.key !== 'nala_walk_anim') {
        if (scene.anims.exists('nala_walk_anim')) s7.nala.play('nala_walk_anim', true);
      }

      // Optional: sync gait to player's when moving
      if (scene.isMoving && scene.player.anims?.currentAnim && s7.nala.anims?.currentAnim) {
        const pf = scene.player.anims.currentFrame;
        const da = s7.nala.anims.currentAnim;
        if (pf && da && da.frames?.length > 0) {
          const idx = pf.index % da.frames.length;
          if (da.frames[idx]) s7.nala.anims.setCurrentFrame(da.frames[idx]);
        }
      }
    } else {
      if (s7.nala.anims?.isPlaying) s7.nala.stop();
      s7.nala.setTexture(s7.nala_idleKey);
    }

    s7.nala.x = nextX;

    // Switch to follow when close enough
    if (s7.nala_mode === 'approachOnce' && Math.abs(desiredX - nextX) <= (s7.nala_moveEps * 3)) {
      s7.nala_mode = 'follow';
    }
  },
},

/* ===================== SCENA 8 — Propuesta: Sofía espera, ring popup, Joaquín se arrodilla ===================== */
/* ===================== SCENE 8 — Propuesta ===================== */
8: {
  manifest: {
    images: [
      { key:'scene8',     path:'/assets/scenes/scene8/scene8.png' }, // tu fondo para la escena 8
      { key:'s8_sofia',   path:'/assets/sofia/casual/sofia_standing.png' }, // MISMA imagen, clave propia
      { key:'s8_knee',    path:'/assets/joaquin/casual/joaquin_knee.png' },
      { key:'s8_ring',    path:'/assets/ring/ring17.png' }
    ]
  },

  build(scene, container){
    // ---------- Tunables ----------
    const SOFIA_REL_W   = 0.085; // tamaño Sofía relativo al ancho del fondo
    const KNEEL_REL_W   = 0.025; // << Cambia aquí la escala de joaquin_knee (p.ej. 0.080 más chico)
    const RING_REL_W    = 0.065; // << Cambia aquí la escala del anillo
    const TRIGGER_RADIUS = 120;  // distancia para activar la secuencia
    const STOP_GAP       = 20;   // a qué distancia se detiene el player frente a Sofía
    const STEP_MS        = 1500; // pausas de 1.5 s entre mensajes/acciones
    const BOB_PX         = 3;    // respiración idle de Sofía
    // --------------------------------

    // Base
    const baseSrc = scene.textures.get('scene8').getSourceImage();
    const baseW   = baseSrc.width;

    // Sofía, centrada dentro del container (detrás del player)
    const sofW  = scene.textures.get('s8_sofia').getSourceImage().width;
    const sofia = scene.add.sprite(0, 0, 's8_sofia')
      .setOrigin(0.5, 1)
      .setScale((SOFIA_REL_W * baseW) / sofW)
      .setDepth(5);
    container.add(sofia);

    // Suave bob
    scene.tweens.add({
      targets: sofia,
      y: `-=${BOB_PX}`,
      duration: 2200,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });

    // Sprites de "arrodillado" y "anillo" en espacio de mundo (no en container)
    const kneeW = scene.textures.get('s8_knee').getSourceImage().width;
    const kneeSprite = scene.add.sprite(0, scene.railY, 's8_knee')
      .setOrigin(0.5,1)
      .setScale((KNEEL_REL_W * baseW) / kneeW)
      .setVisible(false)
      .setDepth(995); // debajo del player (1000), encima de Sofía
    // Anillo
    const ringW = scene.textures.get('s8_ring').getSourceImage().width;
    const ringSprite = scene.add.image(0, scene.railY, 's8_ring')
      .setOrigin(0.5,1)
      .setScale((RING_REL_W * baseW) / ringW)
      .setVisible(false)
      .setDepth(960);

    // Estado escena 8
    scene._s8 = {
      container, sofia,
      baseW, STEP_MS, TRIGGER_RADIUS, STOP_GAP,
      kneeSprite, ringSprite,
      timers: [],
      sequenceRunning: false,
      playedOnce: false,

      // Helpers
      killTimers(){
        (this.timers||[]).forEach(t=>{ try{ t.remove(false); }catch{} });
        this.timers = [];
      },

      // Colocar knee y ring cerca del jugador
      showKneeAndRing(){
        const p = scene.player;
        // ocultar player mientras está arrodillado
        p.setVisible(false);

        this.kneeSprite.setPosition(p.x, scene.railY);
        this.kneeSprite.setFlipX(p.flipX).setVisible(true);

        // Colocamos el anillo un poco hacia delante y arriba del knee
        const kneeH = this.kneeSprite.displayHeight || 100;
        const offX  = p.flipX ? -28 : 28;
        const offY  = Math.max(36, Math.round(kneeH * 0.35));
        this.ringSprite.setPosition(p.x + offX, scene.railY - offY).setVisible(true);
      },

      hideRing(){
        this.ringSprite.setVisible(false);
      },

      restorePlayer(){
        // volver a mostrar al player y ocultar el knee
        scene.player.setVisible(true);
        this.kneeSprite.setVisible(false);
      },

      // Ejecuta la secuencia UNA SOLA VEZ
      runSequence(){
        if (this.sequenceRunning || this.playedOnce) return;
        this.sequenceRunning = true;
        this.playedOnce = true;

        // Bloquear controles y parar justo frente a Sofía
        const sx = this.container.scaleX || 1;
        const sofWorldX = this.container.x + (this.sofia.x * sx);
        scene._controlsLocked = true;
        scene._lockStopX = (scene.player.x < sofWorldX) ? (sofWorldX - this.STOP_GAP) : (sofWorldX + this.STOP_GAP);

        // Player idle
        const who = GameState.character || 'joaquin';
        scene.player.stop().setTexture(scene._idleKey || `${who}_idle`);
        scene.isMoving = false;

        // Proxy para usar helpers de globos (_s4*)
        scene._s4 = { container: this.container, npc: this.sofia, ui:null, uiFollow:null, bubble:null, npcBubble:null };

        const add = (delay, fn) => this.timers.push(scene.time.delayedCall(delay, fn));

        let t = 0;

        // Sofía: "Qué lindo se ve acá"
        add(t += 0, () => { _s4ShowNpcBubble(scene, "Qué lindo se ve acá"); });

        // Espera 1.5s → Player: "Tengo que hacerte una pregunta"
        add(t += this.STEP_MS, () => { _s4ShowBubble(scene, "Tengo que hacerte una pregunta"); });

        // Espera 1.5s → Arrodillarse + mostrar anillo
        add(t += this.STEP_MS, () => { this.showKneeAndRing(); });

        // Espera 1.5s → ocultar anillo
        add(t += this.STEP_MS, () => { this.hideRing(); });

        // Player: "¿Quieres casarte conmigo?"
        add(t += 0, () => { _s4ShowBubble(scene, "¿Quieres casarte conmigo?"); });

        // Espera 1.5s → Sofía: "¡Sí!"
        add(t += this.STEP_MS, () => { _s4ShowNpcBubble(scene, "¡Sí! 💍"); });

        // Espera 1.5s → liberar controles y restaurar player
        add(t += this.STEP_MS, () => {
          this.restorePlayer();
          scene._controlsLocked = false;
          scene._lockStopX = null;
          this.sequenceRunning = false;
        });
      }
    };

    // Guardar también un proxy para los globos (apunta a Sofía)
    scene._s4 = { container, npc: sofia, ui:null, uiFollow:null, bubble:null, npcBubble:null };
    scene._s4_from8 = true;
  },

  enter(scene){
    const s = scene._s8; if (!s) return;

    // Reajustar/limpiar estado runtime
    s.killTimers();
    s.sequenceRunning = false;

    // Asegurar que knee/ring estén ocultos
    s.kneeSprite.setVisible(false);
    s.ringSprite.setVisible(false);

    // Proxy de globos apuntando a Sofía
    scene._s4 = { container: s.container, npc: s.sofia, ui:null, uiFollow:null, bubble:null, npcBubble:null };
    scene._s4_from8 = true;
  },

  leave(scene){
    const s = scene._s8; if (!s) return;

    s.killTimers();
    s.kneeSprite.setVisible(false);
    s.ringSprite.setVisible(false);

    // Liberar bloqueos por si acaso
    scene._controlsLocked = false;
    scene._lockStopX = null;

    // limpiar proxy de globos si venía de esta escena
    if (scene._s4_from8 && scene._s4) {
      try {
        if (scene._s4.bubble?.destroy)    scene._s4.bubble.destroy(true);
        if (scene._s4.npcBubble?.destroy) scene._s4.npcBubble.destroy(true);
      } catch(_) {}
      delete scene._s4_from8;
      delete scene._s4;
    }

    scene._s8 = null;
  },

  update(scene, dt = 0.016){
    const s = scene._s8; if (!s) return;

    // Sofía mira al jugador
    const sx = s.container.scaleX || 1;
    const sofWorldX = s.container.x + (s.sofia.x * sx);
    s.sofia.setFlipX(scene.player.x < sofWorldX);

    // Disparar secuencia solo si aún no corrió y no está corriendo
    if (!s.playedOnce && !s.sequenceRunning) {
      const near = Math.abs(scene.player.x - sofWorldX) <= s.TRIGGER_RADIUS;
      if (near) s.runSequence();
    }

    // Profundidades: Sofía detrás del player; knee y ring debajo del player también
    s.sofia.setDepth(900);
    s.kneeSprite.setDepth(995);
    s.ringSprite.setDepth(960);
  },
},
9: {
  // Set this to true to test the "finished" flow without waiting for the real date
  S9_FORCE_DONE: true,

  manifest: {
    images: [
      { key:'scene9',        path:'/assets/scenes/scene9/scene9.png' },
      { key:'s9_sofia_wedd', path:'/assets/sofia/sofia_wedd.png' }
    ]
  },

  _destroyCountdown(scene){
    const s = scene._c9; if (!s) return;
    if (s.timer){ try{s.timer.remove(false);}catch{} s.timer = null; }
    if (s.container?._c9_follow){ try{s.container._c9_follow.remove(false);}catch{} s.container._c9_follow = null; }
    if (s.ui){ try{s.ui.destroy(true);}catch{} s.ui = null; }
  },

  build(scene, container){
    // ---------- CONFIG ----------
    const TARGET_ISO = '2026-03-07T12:00:00-03:00';
    const finishedByDate = (new Date() >= new Date(TARGET_ISO));
    const FINISHED = this.S9_FORCE_DONE || finishedByDate;

    // (Countdown UI palette)
    const SCALE_UI   = 1.0;
    const TITLE_TXT  = 'PRÓXIMAMENTE…';
    const COL_CARD      = 0x1a1f26;
    const COL_CARD_TOP  = 0x12161c;
    const COL_STROKE    = 0x00ffff;
    const COL_NUM       = '#ffffff';
    const COL_SHADOW    = '#003b3b';
    const COL_LABEL     = '#ffcc66';

    const bgSrc = scene.textures.get('scene9').getSourceImage();

    // Core scene state
    scene._c9 = {
      container,
      ui: null,
      timer: null,
      finished: FINISHED,
      target: new Date(TARGET_ISO),

      // Sofia (only when FINISHED)
      sofiaWedd: null,

      // Proximity + dialog (only when FINISHED)
      triggerRadius: 120,
      stopGap: 18,
      locking: false,
      doneOnce: false,
      dialogTimers: [],

      // Idle override management
      prevIdleKey: null,

      // Blocks (countdown)
      blocks: null
    };

    // Helpers
    const centerPos = ()=>{
      const sx = container.scaleX || 1, sy = container.scaleY || 1;
      const topY = container.y - (bgSrc.height * sy);
      return { x: container.x, y: topY + (bgSrc.height * sy) * 0.42 };
    };

    // MODE A — COUNTDOWN (not finished yet): show timer UI only; no Sofía, no locks.
    if (!FINISHED) {
      const p0 = centerPos();
      const ui = scene.add.container(0,0).setDepth(6000);
      scene._c9.ui = ui;

      const CARD_W = 780 * SCALE_UI, CARD_H = 210 * SCALE_UI;
      const cardShadow = scene.add.rectangle(p0.x+3, p0.y+5, CARD_W, CARD_H, 0x000000, 0.35).setOrigin(0.5);
      const card       = scene.add.rectangle(p0.x,   p0.y,   CARD_W, CARD_H, COL_CARD, 0.95)
                              .setOrigin(0.5).setStrokeStyle(6, COL_STROKE, 1);
      ui.add(cardShadow); ui.add(card);

      const topStrip = scene.add.rectangle(p0.x, p0.y - CARD_H/2 + 18*SCALE_UI, CARD_W-18*SCALE_UI, 28*SCALE_UI, COL_CARD_TOP, 1).setOrigin(0.5);
      ui.add(topStrip);

      const tY = topStrip.y;
      const titleShadow = scene.add.text(p0.x+1, tY+1, TITLE_TXT, { fontFamily:'monospace', fontSize:20*SCALE_UI, color:COL_SHADOW, letterSpacing:1 }).setOrigin(0.5);
      const title       = scene.add.text(p0.x,   tY,   TITLE_TXT, { fontFamily:'monospace', fontSize:20*SCALE_UI, color:'#a0f0ff', letterSpacing:1 }).setOrigin(0.5);
      ui.add(titleShadow); ui.add(title);

      const BOX_W = 150*SCALE_UI, BOX_H = 110*SCALE_UI, GAP = 20*SCALE_UI;
      const makeFlipBlock = (i, labelTxt, anchorX, baseY) => {
        const x = anchorX + i*(BOX_W+GAP), y = baseY;
        const shadow = scene.add.rectangle(x+3,y+4,BOX_W,BOX_H,0x000000,0.35).setOrigin(0.5);
        const box    = scene.add.rectangle(x,y,BOX_W,BOX_H,COL_CARD_TOP,1).setOrigin(0.5).setStrokeStyle(4,COL_STROKE,1);
        ui.add(shadow); ui.add(box);

        const mid = scene.add.line(0,0,x, y-BOX_H/2, x, y, 0x000000, 0.20).setLineWidth(2);
        ui.add(mid);

        const valShadow = scene.add.text(x+1, y-10+1, '00', { fontFamily:'monospace', fontSize:46*SCALE_UI, color:COL_SHADOW }).setOrigin(0.5);
        const val       = scene.add.text(x,   y-10,   '00', { fontFamily:'monospace', fontSize:46*SCALE_UI, color:COL_NUM    }).setOrigin(0.5);
        ui.add(valShadow); ui.add(val);

        const lab = scene.add.text(x, y + BOX_H/2 - 18*SCALE_UI, labelTxt, { fontFamily:'monospace', fontSize:14*SCALE_UI, color:COL_LABEL }).setOrigin(0.5);
        ui.add(lab);

        const flipTo = (txt)=>{
          if (val.text === txt) return;
          scene.tweens.add({
            targets:[val, valShadow],
            scaleY:0, duration:120, ease:'Quad.easeIn',
            onComplete:()=>{
              val.setText(txt); valShadow.setText(txt);
              scene.tweens.add({ targets:[val,valShadow], scaleY:1, duration:120, ease:'Quad.easeOut' });
            }
          });
        };

        return { val, valShadow, flipTo, box, shadow, lab };
      };

      const baseY = p0.y + 28*SCALE_UI;
      const startX = p0.x - (BOX_W*4 + GAP*3)/2 + BOX_W/2;

      const bDays = makeFlipBlock(0,'DÍAS',     startX, baseY);
      const bHrs  = makeFlipBlock(1,'HORAS',    startX, baseY);
      const bMin  = makeFlipBlock(2,'MINUTOS',  startX, baseY);
      const bSec  = makeFlipBlock(3,'SEGUNDOS', startX, baseY);

      container._c9_follow = scene.time.addEvent({
        delay:16, loop:true, callback:()=>{
          const p = centerPos();
          const ny = p.y + 28*SCALE_UI;
          const nx0 = p.x - (BOX_W*4 + GAP*3)/2 + BOX_W/2;
          card.setPosition(p.x,p.y); cardShadow.setPosition(p.x+3,p.y+5);
          topStrip.setPosition(p.x, p.y - CARD_H/2 + 18*SCALE_UI);
          [[bDays,0],[bHrs,1],[bMin,2],[bSec,3]].forEach(([b,i])=>{
            const x = nx0 + i*(BOX_W+GAP), y = ny;
            b.box.setPosition(x,y); b.shadow.setPosition(x+3,y+4);
            b.val.setPosition(x,y-10); b.valShadow.setPosition(x+1,y-9);
            b.lab.setPosition(x,y + BOX_H/2 - 18*SCALE_UI);
          });
          title.setPosition(p.x, topStrip.y);
          titleShadow.setPosition(title.x+1, title.y+1);
        }
      });

      scene._c9.blocks = { days:bDays, hrs:bHrs, min:bMin, sec:bSec };
    }

    // MODE B — FINISHED: show Sofía only (no countdown)
    else {
      const SOFIA_REL_W = 0.185;
      const sofImg   = scene.textures.get('s9_sofia_wedd').getSourceImage();
      const sofScale = (SOFIA_REL_W * bgSrc.width) / sofImg.width;

      const sofiaWedd = scene.add
        .sprite(0, 0, 's9_sofia_wedd')
        .setOrigin(0.5, 1)
        .setScale(sofScale)
        .setDepth(6)
        .setFlipX(true);
      container.add(sofiaWedd);
      scene._c9.sofiaWedd = sofiaWedd;

      // Gentle bob
      scene.tweens.add({
        targets: sofiaWedd,
        y: '-=3',
        duration: 2200,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });
    }
  },

  enter(scene){
    const s = scene._c9; if (!s) return;

    // COUNTDOWN MODE
    if (!s.finished) {
      const pad2 = n => String(Math.floor(n)).padStart(2,'0');
      const target = s.target.getTime();
      const destroyCountdown = ()=> this._destroyCountdown(scene);

      const tick = ()=>{
        if (!scene._c9 || scene._c9.finished) return;
        const now  = Date.now();
        const diff = target - now;

        if (diff <= 0){
          destroyCountdown();
          s.finished = true;    // next time scene is rebuilt/entered it will be in FINISHED mode
          return;
        }
        const sec  = Math.floor(diff/1000);
        const days = Math.floor(sec / 86400);
        const hrs  = Math.floor((sec % 86400) / 3600);
        const mins = Math.floor((sec % 3600) / 60);
        const secs = sec % 60;

        s.blocks.days.flipTo(String(days).padStart(2,'0'));
        s.blocks.hrs .flipTo(pad2(hrs));
        s.blocks.min .flipTo(pad2(mins));
        s.blocks.sec .flipTo(pad2(secs));
      };

      tick();
      s.timer = scene.time.addEvent({ delay:1000, loop:true, callback:tick });
      return;
    }

    // FINISHED MODE — set player idle override to wedding while in this scene
    s.prevIdleKey = scene._idleKey;
    scene._idleKey = 'joaquin_wedd';
  },

  leave(scene){
    const s = scene._c9; if (!s) return;

    // Cleanup countdown
    this._destroyCountdown(scene);

    // Cleanup messages/locks
    (s.dialogTimers||[]).forEach(t=>{ try{ t.remove(false); }catch{} });
    s.dialogTimers = [];
    if (scene._s4?.bubble?.destroy)    try{ scene._s4.bubble.destroy(true); }catch{}
    if (scene._s4?.npcBubble?.destroy) try{ scene._s4.npcBubble.destroy(true); }catch{}
    scene._controlsLocked = false;
    scene._lockStopX = null;

    // Restore previous idle if we changed it
    if (s.prevIdleKey) {
      scene._idleKey = s.prevIdleKey;
      s.prevIdleKey = null;
    }

    scene._c9 = null;
  },

  update(scene, dt = 0.016){
    const s = scene._c9; if (!s) return;

    // If countdown is still active → nothing else to do here.
    if (!s.finished) return;

    // FINISHED: proximity → perma-lock, dual dialog, final message at 5s (still locked)
    const sx = s.container.scaleX || 1;
    const sofWorldX = s.container.x + ((s.sofiaWedd?.x || 0) * sx);

    // Sofía faces the player
    if (s.sofiaWedd) s.sofiaWedd.setFlipX(scene.player.x < sofWorldX);

    if (!s.doneOnce && !s.locking) {
      const dx = Math.abs(scene.player.x - sofWorldX);
      if (dx <= s.triggerRadius) {
        s.locking = true;

        // Stop & perma-lock player here
        scene._controlsLocked = true;
        scene._lockStopX = (scene.player.x < sofWorldX) ? (sofWorldX - s.stopGap) : (sofWorldX + s.stopGap);

        // Force wedding idle immediately and face Sofía once
        scene.player.stop().setTexture('joaquin_wedd');
        scene.player.setFlipX(scene.player.x > sofWorldX);
        scene.isMoving = false;

        // Bubble helpers target Sofía
        scene._s4 = { container: s.container, npc: s.sofiaWedd, ui:null, uiFollow:null, bubble:null, npcBubble:null };

        const timers = [];
        // Sofía: "¡si, acepto!"
        timers.push(scene.time.delayedCall(0, () => {
          _s4ShowNpcBubble(scene, "¡si, acepto!");
        }));
        // Player: "¡si, acepto!"
        timers.push(scene.time.delayedCall(400, () => {
          _s4ShowBubble(scene, "¡si, acepto!");
        }));
        // After 5s: final message; REMAIN LOCKED
        timers.push(scene.time.delayedCall(700, () => {
  // Launch the finisher. Play remains locked; we’ll stop it at the end of the overlay.
  scene.scene.launch('FinalPhotoStrip');
  scene.scene.bringToTop('FinalPhotoStrip');
}));


        s.dialogTimers = timers;
      }
    }
  },
},
};

  // -------------------- CORE SCENES --------------------
  class StartMenu extends Phaser.Scene {
    constructor(){ super('StartMenu'); }
    create(){
      const { width, height } = this.scale;
      this.add.text(width/2, height*0.3, 'MEMORY WALK', { fontFamily:'monospace', fontSize:32, color:'#ffffff' }).setOrigin(0.5);
      const btn = this.add.text(width/2, height*0.55, '[ START ]', { fontFamily:'monospace', fontSize:24, color:'#00ffff', backgroundColor:'#111' }).setOrigin(0.5).setInteractive({ useHandCursor:true });
      btn.on('pointerup', ()=> this.scene.start('SoundSelect'));
    }
  }

  class SoundSelect extends Phaser.Scene {
    constructor(){ super('SoundSelect'); }

    preload(){
      this.load.audio('bgm', ['/assets/audio/bgm.mp3']);
    }

    create(){
      const { width, height } = this.scale;
      this.add.text(width/2, height*0.3, 'SOUND?', { fontFamily:'monospace', fontSize:28, color:'#ffffff' }).setOrigin(0.5);
      this._btn(width/2 - 80, height*0.55, '[ ON ]',  ()=> this._choose(true));
      this._btn(width/2 + 80, height*0.55, '[ OFF ]', ()=> this._choose(false));
    }
    _btn(x,y,label,onClick){
      const t = this.add.text(x,y,label,{ fontFamily:'monospace', fontSize:22, color:'#00ffff', backgroundColor:'#111' }).setOrigin(0.5).setInteractive({ useHandCursor:true });
      t.on('pointerup', onClick);
      return t;
    }
    _choose(on){
      GameState.sound = on;

      if (!GameState.bgm) {
        GameState.bgm = this.sound.add('bgm', { loop:true, volume:0.12 });
      } else {
        this.sound.removeByKey('bgm');
        GameState.bgm = this.sound.add('bgm', { loop:true, volume:0.12 });
      }
      if (on) {
        if (!GameState.bgm.isPlaying) GameState.bgm.play();
      } else {
        if (GameState.bgm.isPlaying) GameState.bgm.pause();
      }

      this.scene.start('CharacterSelect');
    }
    
  }

class FinalPhotoStrip extends Phaser.Scene {
  constructor(){ super('FinalPhotoStrip'); }

  preload(){
    // Asegura que TODOS los fondos scene1..scene9 estén disponibles
    for (let i=1;i<=9;i++){
      const key = `scene${i}`;
      if (!this.textures.exists(key)) {
        this.load.image(key, `/assets/scenes/scene${i}/scene${i}.png`);
      }
    }
  }

  create(){
    const { width:W, height:H } = this.scale;

    // --- CORTE DURO DE AUDIO ---
    try {
      this.sound.stopAll();
      if (window.GameState?.bgm) { try { GameState.bgm.stop(); } catch(_) {} GameState.bgm = null; }
      if (this.sound.context && this.sound.context.state !== 'suspended') {
        this.sound.context.suspend().catch(()=>{});
      }
    } catch(_) {}

    // --- Fondo oscurecido ---
    const dim = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0.0)
      .setDepth(20000).setScrollFactor(0);
    this.tweens.add({ targets: dim, alpha: 0.65, duration: 500, ease: 'Sine.easeOut' });

    // --- Helper Polaroid ---
    const mkPolaroid = (texKey, caption='')=>{
      const pw = Math.min(280, W*0.30), ph = Math.round(pw*1.25);
      const frame = this.add.rectangle(0,0,pw,ph,0xffffff,1)
        .setStrokeStyle(3, 0xeeeeee, 1).setOrigin(0.5,0.5);
      const innerW = pw - 22, innerH = ph - 64;

      const img = this.add.image(0, -6, texKey).setOrigin(0.5,0.5);
      const src = this.textures.get(texKey)?.getSourceImage();
      if (src) img.setScale(Math.min(innerW/src.width, innerH/src.height));

      const cap = this.add.text(0, ph/2 - 28, caption, {
        fontFamily:'monospace', fontSize: 14, color:'#333333', align:'center', wordWrap:{ width: pw-20 }
      }).setOrigin(0.5,0.5);

      const c = this.add.container(W/2, -ph, [frame, img, cap]).setDepth(20001);
      c._pw = pw; c._ph = ph;

      // sombra suave
      c._shadow = this.add.rectangle(W/2+6, -ph+8, pw, ph, 0x000000, 0.25)
        .setDepth(20000).setOrigin(0.5,0.5);
      return c;
    };

    // --- Polaroids: scene1..scene9 ---
    const picks = [];
    for (let i=1;i<=9;i++){
      const k = `scene${i}`;
      if (this.textures.exists(k)) picks.push([k, `Escena ${i}`]);
    }
    // Completa a 9 si faltara alguna
    while (picks.length < 9 && picks.length > 0) {
      picks.push(picks[picks.length % Math.max(1,picks.length)]);
    }
    const photos = picks.slice(0,9).map(([k,cap])=> mkPolaroid(k, cap));

    // --- Layout 3x3 con leve aleatoriedad ---
    const cols=3, rows=3;
    const marginX = Math.min(80, W*0.06);
    const marginY = Math.min(70, H*0.06);
    const gridW = W - marginX*2, gridH = H - marginY*2;
    const cellW = gridW/cols, cellH = gridH/rows;
    const jitter = v => (Math.random()*v*2 - v);

    const targets = [];
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        const x = marginX + cellW*(c+0.5);
        const y = marginY + cellH*(r+0.5);
        const baseR = ((r+c)%2===0) ? -0.06 : 0.08;
        targets.push({ x, y, rot: baseR + jitter(0.03) });
      }
    }

    // --- Caída escalonada ---
    photos.forEach((p, i)=>{
      const L = targets[i % targets.length];
      const delay = 240 + i*220;
      p.setRotation((L.rot>0?L.rot-0.3:L.rot+0.3)); // arranca más girada
      this.tweens.add({
        targets: p._shadow, delay, duration: 650, ease: 'Back.Out',
        x: L.x+6 + jitter(4), y: L.y+8 + jitter(4)
      });
      this.tweens.add({
        targets: p, delay, duration: 650, ease: 'Back.Out',
        x: L.x + jitter(6), y: L.y + jitter(6), rotation: L.rot
      });
    });

    // --- Sello final: "Felices por siempre" (blanco, borde negro, sombra; por encima de todo) ---
    const STAMP_TEXT = 'Felices por siempre';
    const stampDepth = 30002;              // por encima de fotos (20001) y sombras (20000)
    const stampY     = H * 0.12;
    const fontSize   = Math.min(58, W*0.075);

    // Texto principal
    const stamp = this.add.text(W/2, stampY, STAMP_TEXT, {
      fontFamily: 'monospace',
      fontSize: fontSize,
      color: '#ffffff',
      align: 'center',
      letterSpacing: 1
    })
    .setOrigin(0.5)
    .setDepth(stampDepth)
    .setAlpha(0)
    .setScale(1.35)
    .setRotation(-0.06)
    .setStroke('#000000', Math.max(4, Math.round(fontSize * 0.12))) // borde negro proporcional
    .setShadow(0, Math.max(2, Math.round(fontSize * 0.05)), '#000000', Math.max(6, Math.round(fontSize * 0.1)), true, true); // sombra

    // Sombra desplazada adicional (más presencia)
    const stampDrop = this.add.text(W/2 + 3, stampY + 3, STAMP_TEXT, {
      fontFamily: 'monospace',
      fontSize: fontSize,
      color: '#000000',
      align: 'center',
      letterSpacing: 1
    })
    .setOrigin(0.5)
    .setDepth(stampDepth - 1)
    .setAlpha(0)
    .setScale(1.35)
    .setRotation(-0.06);

    // Subtítulo
    const sub = this.add.text(W/2, stampY + Math.min(64, H*0.065), '¡Que vivan los novios!', {
      fontFamily:'monospace',
      fontSize: Math.min(22, W*0.03),
      color:'#ffffff'
    })
    .setOrigin(0.5)
    .setDepth(stampDepth)
    .setAlpha(0)
    .setStroke('#000000', 3)
    .setShadow(0, 2, '#000000', 6, true, true);

    // Tiempo tras la caída de polaroids
    const afterDrop = 240 + photos.length*220 + 260;

    // Animación de entrada del sello
    this.time.delayedCall(afterDrop, ()=>{
      stamp.setAlpha(1);
      stampDrop.setAlpha(0.45); // sutil
      this.tweens.add({
        targets: [stamp, stampDrop],
        duration: 280,
        ease: 'Back.Out',
        scale: 1.0,
        rotation: -0.02
      });
    });

    // Aparición del subtítulo
    this.tweens.add({
      targets: sub,
      delay: afterDrop + 320,
      duration: 620,
      alpha: 1,
      ease: 'Sine.easeOut'
    });

    // --- Vignette + pequeño zoom de cámara ---
    const vignette = this.add.graphics().setDepth(20003);
    this.tweens.add({
      targets: vignette, delay: 300, duration: 1000,
      onUpdate: (_, t)=>{
        vignette.clear();
        vignette.fillStyle(0x000000, 0.20*Math.min(1,t));
        vignette.fillRect(0,0,W,H);
      }
    });
    this.cameras.main.setZoom(1);
    this.tweens.add({ targets: this.cameras.main, zoom: 1.04, duration: 1600, delay: afterDrop, ease: 'Sine.easeInOut' });

    // --- Auto–fade a Start Menu ---
    const total = afterDrop + 2200; // ~3.5–4.0 s total
    this.time.delayedCall(total, ()=>{
      this.cameras.main.fadeOut(900, 0,0,0);
      this.cameras.main.once(Phaser.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, ()=>{
        const play = this.scene.get('Play');
        if (play) { play.scene.stop(); }
        this.scene.stop();
        this.scene.start('StartMenu');
      });
    });

    // --- Mantener sello centrado en resize (no reacomodamos fotos en vuelo) ---
    this.scale.on('resize', (size)=>{
      dim.setSize(size.width, size.height).setPosition(size.width/2, size.height/2);
      const ny = size.height * 0.12;
      stamp.setPosition(size.width/2, ny);
      stampDrop.setPosition(size.width/2 + 3, ny + 3);
      sub.setPosition(size.width/2, ny + Math.min(64, size.height*0.065));
    });
  }
}

  class CharacterSelect extends Phaser.Scene {
    constructor(){ super('CharacterSelect'); }
    preload(){
      this.load.image('joaquin_idle', '/assets/joaquin/scene1/joaquin_standing.png');
      for (let i=1;i<=6;i++) this.load.image(`joaquin_walk${i}`, `/assets/joaquin/scene1/joaquin_walk${i}.png`);
      this.load.image('sofia_idle', '/assets/sofia/scene1/sofia_standing.png');
      for (let i=1;i<=6;i++) this.load.image(`sofia_walk${i}`, `/assets/sofia/scene1/sofia_walk${i}.png`);
    }
    create(){
      const { width, height } = this.scale;
      this.add.text(width/2, height*0.2, 'CHOOSE YOUR CHARACTER', { fontFamily:'monospace', fontSize:24, color:'#ffffff' }).setOrigin(0.5);

      const joaquin = this.add.image(width/2 - 120, height*0.70, 'joaquin_idle')
        .setOrigin(0.5,1).setScale(0.6).setInteractive({ useHandCursor:true });
      const joaquinLabel = this.add.text(joaquin.x, joaquin.y+12, 'JOAQUÍN',
        { fontFamily:'monospace', fontSize:18, color:'#00ffff' }).setOrigin(0.5,0).setInteractive({ useHandCursor:true });

      const sofia = this.add.image(width/2 + 120, height*0.70, 'sofia_idle')
        .setOrigin(0.5,1).setScale(0.6).setInteractive({ useHandCursor:true });
      const sofiaLabel = this.add.text(sofia.x, sofia.y+12, 'SOFÍA',
        { fontFamily:'monospace', fontSize:18, color:'#ff7acb' }).setOrigin(0.5,0).setInteractive({ useHandCursor:true });

      const pick = (who) => { GameState.character = who; this.scene.start('Play'); };

      joaquin.on('pointerup', () => pick('joaquin'));
      joaquinLabel.on('pointerup', () => pick('joaquin'));
      sofia.on('pointerup', () => pick('sofia'));
      sofiaLabel.on('pointerup', () => pick('sofia'));

      // Keyboard shortcuts
      this.input.keyboard.on('keydown-J', () => pick('joaquin'));
      this.input.keyboard.on('keydown-S', () => pick('sofia'));
      this.input.keyboard.on('keydown-ENTER', () => pick('joaquin')); // default
    }
  }

  class Play extends Phaser.Scene {
    constructor(){ super('Play'); }

    preload(){
      const who   = GameState.character || 'joaquin';
      const other = (who === 'sofia') ? 'joaquin' : 'sofia';

      if (!this.textures.exists(`${who}_idle`)) {
        this.load.image(`${who}_idle`, `/assets/${who}/scene1/${who}_standing.png`);
        for (let i=1;i<=6;i++) this.load.image(`${who}_walk${i}`, `/assets/${who}/scene1/${who}_walk${i}.png`);
      }
      if (!this.textures.exists(`${other}_idle`)) {
        this.load.image(`${other}_idle`, `/assets/${other}/scene1/${other}_standing.png`);
        for (let i=1;i<=6;i++) this.load.image(`${other}_walk${i}`, `/assets/${other}/scene1/${other}_walk${i}.png`);
      }

      // Wedding idle de Joaquín (para la escena 9)
if (!this.textures.exists('joaquin_wedd')) {
  this.load.image('joaquin_wedd', '/assets/joaquin/joaquin_wedd.png');
}


      // casual outfit for chosen character
      const whoDir = `/assets/${who}/casual/`;
      if (!this.textures.exists(`${who}_idle_casual`)) {
        this.load.image(`${who}_idle_casual`, `${whoDir}${who}_standing.png`);
        for (let i=1;i<=6;i++) {
          this.load.image(`${who}_walk_casual_${i}`, `${whoDir}${who}_walk${i}.png`);
        }
      }

      this.load.audio('s1_birds',    ['/assets/audio/birds.mp3']);
      this.load.audio('s1_ambience', ['/assets/audio/ambience.mp3']);

      if (!this.cache.audio.exists('bgm')) {
        this.load.audio('bgm', ['/assets/audio/bgm.mp3']);
      }

      // Scene 4 song (Greenday)
      if (!this.cache.audio.exists('scene4_song')) {
        this.load.audio('scene4_song', ['/assets/audio/greenday.mp3']);
      }
    }

    create(){
      this.h = this.scale.height;
      this.railY = Math.round(this.h * 0.8);

      this.COUNT = 9;
      this.SPACING = 1200;
      this.START_X = 700;
      this.TARGET_H = 360;

      this.worldWidth = this.START_X + (this.COUNT - 1)*this.SPACING + 600;
      this.cameras.main.setBounds(0, 0, this.worldWidth, this.h);

      this.gfx = this.add.graphics().setDepth(-10);
      this._drawGround();

      const who = GameState.character || 'joaquin';
      this._ensureWalkAnim(who);

      this.player = this.add.sprite(150, this.railY, `${who}_idle`).setOrigin(0.5,1).setScale(0.2).setDepth(1000);

      this._walkKey = `${who}_walk`;
      this._idleKey = `${who}_idle`;

      this.cameras.main.startFollow(this.player, true, 0.15, 0.15);

      this.cursors = this.input.keyboard.createCursorKeys();
      this.keyA = this.input.keyboard.addKey('A');
      this.keyD = this.input.keyboard.addKey('D');
      this.speed = 200;
      this.isMoving = false;

      // Audio unlock on first user gesture (mobile & Safari)
      this.input.once('pointerdown', () => {
        if (this.sound.locked) this.sound.unlock();
        if (this.sound.context && this.sound.context.state === 'suspended') {
          this.sound.context.resume().catch(()=>{});
        }
      });

      this.thoughtBubble = this.add.text(
        this.player.x, this.player.y - this.player.displayHeight - 40,
        "Aquí empezó todo...",
        { fontFamily:"monospace", fontSize:14, color:"#ffffff", backgroundColor:"#000000" }
      ).setOrigin(0.5,1).setDepth(3000).setAlpha(0);
      this._bubbleVisible = false;

      this.zone = { current: null, containers: Array(this.COUNT).fill(null), loaded: new Set() };
      this._ensureZone(1);
      this._ensureNeighbors(1);

      this.help = this.add.text(this.player.x, this.player.y - this.player.displayHeight - 8,'Use \u2190 / \u2192 to walk',{ fontFamily:'monospace', fontSize:14, color:'#ffffff' }).setOrigin(0.5,1).setDepth(2000);

      this._outfitBoundaryX = this._zoneBounds(3).right;
      this._lastX = this.player.x;

      if (this.player.x >= this._outfitBoundaryX) this._applyOutfit('casual'); else this._applyOutfit('primary');

      if (!GameState.bgm) {
        GameState.bgm = this.sound.add('bgm', { loop:true, volume:0.1 });
      }
      this.bgm = GameState.bgm;

      this.ambBirds = this.sound.add('s1_birds',    { loop:true, volume:0.1 });
      this.ambAtmo  = this.sound.add('s1_ambience', { loop:true, volume:0.3 });

      const UI_RIGHT_GUTTER = 80;
      this.soundIcon = this.add.text(this.scale.width - UI_RIGHT_GUTTER, 16,
        (GameState.sound && this.bgm.isPlaying ? '🔊' : '🔇'),
        { fontFamily:'monospace', fontSize:24, color:'#ffffff' })
        .setOrigin(1,0)
        .setScrollFactor(0)
        .setDepth(5000)
        .setInteractive({ useHandCursor:true });

      // Sound toggle
      this.soundIcon.on('pointerup', () => {
        const turnOn = !(GameState.sound && (
          (this.bgm && (this.bgm.isPlaying || this.bgm.isPaused)) ||
          (this._s4 && this._s4.song && (this._s4.song.isPlaying || this._s4.song.isPaused))
        ));
        GameState.sound = turnOn;

        if (turnOn) {
          if (this.zone.current !== 4 || !(this._s4 && this._s4.songPlaying)) {
            if (this.bgm && !this.bgm.isPlaying) this.bgm.isPaused ? this.bgm.resume() : this.bgm.play();
          }
          if (this.zone.current === 1) {
            if (this.ambBirds && !this.ambBirds.isPlaying) this.ambBirds.play();
            if (this.ambAtmo  && !this.ambAtmo.isPlaying)  this.ambAtmo.play();
          }
          if (this.zone.current === 4 && this._s4 && this._s4.song && this._s4.song.isPaused) {
            this._s4.song.resume();
          }
          this.soundIcon.setText('🔊');
        } else {
          if (this.bgm && this.bgm.isPlaying) this.bgm.pause();
          if (this.ambBirds && this.ambBirds.isPlaying) this.ambBirds.pause();
          if (this.ambAtmo  && this.ambAtmo.isPlaying)  this.ambAtmo.pause();
          if (this._s4 && this._s4.song && this._s4.song.isPlaying) this._s4.song.pause();
          this.soundIcon.setText('🔇');
        }
      });

      this.scale.on('resize', (size) => {
        this.soundIcon.setPosition(size.width - UI_RIGHT_GUTTER, 16);
      });
    }

    update(_, dtMS){
      const dt = dtMS / 1000;

      const left  = this.cursors.left.isDown || this.keyA.isDown;
      const right = this.cursors.right.isDown || this.keyD.isDown;
      let dir = right && !left ? 1 : left && !right ? -1 : 0;

      if (this._controlsLocked) dir = 0;

      const who = GameState.character || 'joaquin';
      if (dir !== 0) {
        const nx = Phaser.Math.Clamp(this.player.x + dir * this.speed * dt, 0, this.worldWidth);
        this.player.setX(nx).setFlipX(dir < 0);
        const walkKey = this._walkKey || `${who}_walk`;
        if (!this.isMoving || this.player.anims.currentAnim?.key !== walkKey) {
          this.player.play(walkKey, true);
          this.isMoving = true;
        }
      } else if (this.isMoving) {
        this.player.stop().setTexture(this._idleKey || `${who}_idle`);
        this.isMoving = false;
      }

      // clamp when locked
      if (this._lockStopX != null) {
        if (this.player.x < this._lockStopX && !this.player.flipX) {
          this.player.x = Math.min(this.player.x, this._lockStopX);
        } else if (this.player.x > this._lockStopX && this.player.flipX) {
          this.player.x = Math.max(this.player.x, this._lockStopX);
        }
      }

      const b = this._outfitBoundaryX;
      const prevX = this._lastX;
      const curX  = this.player.x;

      if (prevX < b && curX >= b) this._applyOutfit('casual');
      else if (prevX >= b && curX < b) this._applyOutfit('primary');
      this._lastX = curX;

      let idx = Math.floor(
        (this.player.x - (this.START_X - this.SPACING / 2)) / this.SPACING
      ) + 1;

      idx = Phaser.Math.Clamp(idx, 1, this.COUNT);
      if (idx !== this.zone.current) this._switchZone(idx);

      const def = ZONE_DEFS[this.zone.current];
      if (def?.update) def.update(this, dt);

      this._ensureNeighbors(this.zone.current || 1);

      this.thoughtBubble.setPosition(this.player.x, this.player.y - this.player.displayHeight - 40);
      this.help.setPosition(this.player.x, this.player.y - this.player.displayHeight - 8);

      if (this._enforceScale) this._enforceScale();

    }

    _drawGround(){
      this.gfx.clear();
      this.gfx.lineStyle(2, 0x00ffff, 1);
      this.gfx.moveTo(0, this.railY);
      this.gfx.lineTo(this.worldWidth, this.railY);
      this.gfx.strokePath();
    }
    _ensureWalkAnim(who){
      const key = `${who}_walk`;
      const framesAvailable = [1,2,3,4,5,6].every(i => this.textures.exists(`${who}_walk${i}`));
      if (framesAvailable && !this.anims.exists(key)) {
        this.anims.create({
          key,
          frames: [1,2,3,4,5,6].map(i => ({ key: `${who}_walk${i}` })),
          frameRate: 12,
          repeat: -1
        });
      }
    }

    _zoneBounds(index){
      const center = this.START_X + (index - 1) * this.SPACING;
      const half   = this.SPACING * 0.5;
      return { left:center - half, right:center + half, center };
    }

    _switchZone(index){
      const prev = this.zone.current;
      if (prev){
        const defPrev = ZONE_DEFS[prev];
        if (defPrev?.leave) defPrev.leave(this);
      }
      this.zone.current = index;
      const defNew = ZONE_DEFS[index];
      if (defNew?.enter) defNew.enter(this);
    }

    _ensureZone(index){
      if (!index || index < 1 || index > this.COUNT) return;
      if (this.zone.loaded.has(index)) return;

      const def = ZONE_DEFS[index] || null;

      let needLoad = false;
      (def?.manifest?.images || []).forEach(img => {
        if (!this.textures.exists(img.key)) { this.load.image(img.key, img.path); needLoad = true; }
      });

      if (!def?.manifest?.images && !this.textures.exists(`scene${index}`)) {
        this.load.image(`scene${index}`, `/assets/scenes/scene${index}/scene${index}.png`);
        needLoad = true;
      }

      if (needLoad) {
        this.load.once(Phaser.Loader.Events.COMPLETE, () => { this._buildZone(index, def); });
        this.load.start();
      } else {
        this._buildZone(index, def);
      }
    }


    _addStaticSceneTitle(container, baseKey, index){
  const src = this.textures.get(baseKey).getSourceImage();
  const label = (ZONE_TITLES[index] || `scene ${index}`).toUpperCase();

  // Local position: centered X, near the top edge of the background
  const localX = 0;
  const localY = -src.height + 40; // 40px below top (container origin is bottom-center)

  // Base font size & stroke get scaled by the container (nice “pixel” feel)
  const baseFontSize = 60;
  const strokeW = 10;

  const t = this.add.text(localX, localY, label, {
    fontFamily: 'monospace',
    fontSize: baseFontSize,
    color: '#ffffff',
    align: 'center',
    letterSpacing: 1
  })
  .setOrigin(0.5, 0)    // centered, top-aligned
  .setDepth(10)         // above the background inside the container
  .setStroke('#000000', strokeW)
  .setShadow(
    0,
    Math.max(2, Math.round(strokeW * 0.6)),
    '#000000',
    Math.max(6, Math.round(strokeW * 1.6)),
    true,
    true
  );

  container.add(t); // attach to container so it scales/moves with the scene
}

    _buildZone(index, def){
      const old = this.zone.containers[index-1];
      if (old) old.destroy(true);

      const { center } = this._zoneBounds(index);
      const baseKey =
        (def?.manifest?.images?.find(i=>i.key.startsWith('scene'))?.key) ||
        `scene${index}`;

      const base = this.add.image(0,0, baseKey).setOrigin(0.5,1).setDepth(0);
      const container = this.add.container(center, this.railY, [base]).setDepth(0);

      const src = this.textures.get(baseKey).getSourceImage();
      const scale = this.TARGET_H / src.height;
      container.setScale(scale);

      const bgColor = ZONE_BG_COLORS[(index - 1) % ZONE_BG_COLORS.length];
      const bg = this.add.rectangle(0, 0, src.width, src.height + 120, bgColor, 1)
        .setOrigin(0.5, 1)
        .setAlpha(ZONE_BG_ALPHA);
      container.addAt(bg, 0);

      if (SHOW_ZONE_EDGES) {
        const edgeH = src.height + 140;
        const edgeW = 6;
        const leftEdge  = this.add.rectangle(-src.width / 2, 0, edgeW, edgeH, 0xffffff, 0.28).setOrigin(0.5, 1);
        const rightEdge = this.add.rectangle( src.width / 2, 0, edgeW, edgeH, 0xffffff, 0.28).setOrigin(0.5, 1);
        container.addAt(rightEdge, 2);
        container.addAt(leftEdge, 1);
      }

      const defObj = ZONE_DEFS[index];
      if (defObj?.build) defObj.build.call(defObj, this, container);

      this.zone.containers[index-1] = container;
      this.zone.loaded.add(index);

      this._addStaticSceneTitle(container, baseKey, index);
    }

   _destroyZone(index){
  if (!this.zone.loaded.has(index)) return;
  const def = ZONE_DEFS[index];

  if (def?.leave) def.leave(this);

  const c = this.zone.containers[index-1];
  if (c){ c.destroy(true); this.zone.containers[index-1] = null; }

  (def?.manifest?.images || []).forEach((img) => {
    if (img.key.startsWith('scene') && this.textures.exists(img.key)) {
      this.textures.remove(img.key);
    }
  });

  this.zone.loaded.delete(index);
  if (index === 2 && this._npc2) { this._npc2.destroy(true); this._npc2 = null; }
  if (index === 1 && this._npc)  { this._npc.destroy(true);  this._npc  = null; }
}


    _ensureNeighbors(index){
      const keep = new Set([1, index-1, index, index+1].filter(i=> i>=1 && i<=this.COUNT));
      keep.forEach(i => this._ensureZone(i));
      for (let i=1;i<=this.COUNT;i++){
        if (!keep.has(i) && this.zone.loaded.has(i)) this._destroyZone(i);
      }
    }

    _buildCasualWalkAnimIfNeeded(){
      const who = GameState.character || 'joaquin';
      const animKey = `${who}_walk_casual`;
      if (this.anims.exists(animKey)) return animKey;
      const frames = [1,2,3,4,5,6].map(i => ({ key: `${who}_walk_casual_${i}` }));
      this.anims.create({ key: animKey, frames, frameRate: 12, repeat: -1 });
      return animKey;
    }

_applyOutfit(mode){
  if (this._currentOutfit === mode) return;

  const who = GameState.character || 'joaquin';

  if (mode === 'casual') {
    const animKey = this._buildCasualWalkAnimIfNeeded();
    this._walkKey = animKey;
    this._idleKey = `${who}_idle_casual`;
  } else {
    this._ensureWalkAnim(who);
    this._walkKey = `${who}_walk`;
    this._idleKey = `${who}_idle`;
  }

  // >>> definitive scales <<<
  // >>> definitive scales <<<
const scaleMap = {
  joaquin: { primary: 0.20, casual: 0.20 },
  sofia:   { primary: 0.18, casual: 0.05 }, // <-- Sofía "casual" más pequeña
};
const target = (scaleMap[who]?.[mode]) ?? 0.20;

this.player.setScale(target);
this._currentOutfit = mode;

// guard: if some scene tweaks scale, we snap back next frame
this._enforceScale = () => {
  if (Math.abs(this.player.scaleX - target) > 0.0001) {
    this.player.setScale(target);
  }
};


  if (this.isMoving) this.player.play(this._walkKey, true);
  else this.player.stop().setTexture(this._idleKey);
}


  }

  new Phaser.Game({
    type: Phaser.AUTO,
    parent: document.getElementById('game-root'),
    width: window.innerWidth,
    height: window.innerHeight,
    backgroundColor:'#000',
    scene: [StartMenu, SoundSelect, CharacterSelect, Play, FinalPhotoStrip],
    scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH },
    render: { pixelArt:true, antialias:false, roundPixels:true },
    resolution: 1
  });
  </script>
</body>
</html>
